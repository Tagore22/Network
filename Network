1강
 네트워크는 자료구조의 그래프와 같은 형태를 띤다. 정점과 간선으로 이루어져 있다.

2강
 네트워크는 자료구조의 그래프와 같이 정점과 간선으로 이루어져 있으며 크게 4가지로 구분할 수 있다.

1. 호스트
 최초로 정보가 발신되는 정점과 최종으로 수신되는 정점을 호스트라고 칭한다. 다만, 상술한 대로
정보의 시작과 끝일 때 호스트라고 불리며, 이 정점이 끝이 아닌 중간지점이 될 수도 있다.
정보를 요청하는 클라이언트와 수신하는 서버로 나누어지며 이 두 가지 개념은 배타적인 개념이 아니고
상황에 따라 바뀔 수 있다.
2. 네트워크 장비
 호스트들을 연결해주는 중간 정점. 상술한 대로 이 정점이 중간 지점이 아닌 정보 이동의 끝이 된다면
호스트가 될 수 있다.
3. 통신 매체
 각 정점을 연결해주는 간선을 의미하며 유선 매체, 무선 매체가 있다.
4. 메세지
 통신 매체로 연결된 노드가 주고받는 정보를 의미한다. 웹 페이지, 파일, 메일 등이 있다.

 주의할 점은 상술한 대로 호스트와 네트워크 장비, 서버와 클라이언트는 배타적인 개념이 아니라는 것이다.
자료를 송수신하는 정점이 호스트, 그 중간다리 역할을 하는 것이 네트워크 장비일 뿐이며, 자료를 요청하는 정점이
클라이언트, 송신하는 정점이 서버일 뿐이다. 어떤 정점은 무조건 서버, 클라이언트, 호스트, 네트워크 장비라고
구분할 수 없으며 상황에 따라 바뀔 수 있다.

3강
 네트워크의 분류

1. 범위에 의한 분류
1-1. LAN(Local Area Network) - 개인 혹은 소규모 조직의 근거리 통신망.
1-2. WAN(Wide Area Network) - 대규모 조직의 광역 통신망. 인터넷이 대표적이며 다른 LAN에 속한 호스트와
메시지를 주고받아야 할 때 필요함. ISP(Internet Service Provider)에서 구축, 관리 및 임대하며 KT, SK, LG 등이 있다.

2. 메세지 교환 방식에 의한 분류
2-1. 회선 교환 네트워크 - 메시지를 주고받기 전 회선을 설정한 뒤, 해당 회선을 통해 메시지를 주고받는 방식.
미리 회선을 설정해놓기 때문에 전송량이 비교적 일정하지만, 마찬가지로 설정해놓기 때문에 다른 회선이 사용할 수 없어서
비효율적인 상황이 존재한다.(예약만 해놓고 사용하지 않거나 사용량이 적을 경우).
2-2. 패킷 교환 네트워크 - 패킷이라는 단위로 쪼개서 전송 후 수신 호스트에서 재조립하는 방식. 전송로의 이용 효율이 높기
때문에 회선 교환 방식의 문제점을 해결하여 현재 인터넷의 대부분은 패킷 교환 방식을 사용함. 각 송신자에서 나누어진
패킷들은 각각 다른 전송로를 통할 수 있기 때문에 수신지에서의 순서와 송신지에서의 순서가 다를 수 있다.

패킷을 택배로 비유하자면 내용물인 페이로드(Payload)와 송장 역할의 헤더(Header), 트레일러(Trailer)로 구분할 수 있다. 

4강
 헤더에는 패킷의 송수신지를 저장할 수 있다. 이때 수신지가 하나일 수도 여러 개일 수도 있다.

 송수신지 유형별 전송 방식에는 다음과 같은 4가지 종류가 있다.

1. 유니캐스트(Unicast) - 송신지와 수신지가 일대일로 메시지를 보내는 경우. 따라서 수신지는 한곳이 되며
가장 일반적인 송수신 형태이다.
2. 브로드캐스트(Broadcast) - 네트워크상의 모든 호스트에게 전송. 이때 브로드캐스트 도메인(Broadcast Domain)이
그 전송 범위가 된다.
3. 멀티캐스트(Multicast) - 네트워크 내의 동일 그룹에 속한 호스트들에게 전송.
4. 애니캐스트(Anycast) - 네트워크 내의 동일 그룹에 속한 호스트들 중 가장 가까운 호스트에게 전송.

5강
 미시적으로 네트워크를 살펴보았을 때 두 대의 컴퓨터가 정보를 주고받는 과정에서 일어나는 일을 뜻한다.

 노드 간에 정보를 올바르게 주고받기 위해 합의된 규칙이나 방법 혹은 언어를 프로토콜(Protocol)이라고 한다.
또한, 프로토콜마다 목적과 특징에 의해 종류별로 나누어지게 된다. 목적과 특징이 달라서 패킷의 헤더 또한 프로토콜마다 달라질 수 있다.

6강
 패킷의 송수신 과정은 계층별로 나누어지며 수신과 송신은 정반대의 순서를 거친다. 통신이 이루어지는 각 과정 계층으로 
 된 구조를 네트워크 참조 모델이라고 한다.

통신 과정을 계층적으로 나눈 이유
1. 네트워크 구성과 설계 용이.
2. 네트워크 문제 진단과 해결이 용이. 유닛테스트처럼 순서대로 문제가 발생했는지 확인해나갈 수 있다.

 대표적인 네트워크 모델
1. OSI 모델(OSI 7계층)
1-1. 물리 계층 - OSI 모델의 최하단으로 가장 기본적인 통신이 이루어지며 1과 0으로 표현되는 비트 신호를 주고받는다.
추가되는 헤더가 없이 이 계층에서 패킷이 신호로 변환되어 전송된다.
1-2. 데이터 링크 계층 - 네트워크 내 주변 장치 간의 정보를 올바르게 주고받기 위한 계층. 보통 물리 계층과 하나로
묶이는 경우가 있으며 주로 LAN과 관련된 기술이다. 패킷 안에 트레일러가 이 과정에서 생성된다.
1-3. 네트워크 계층 - 메시지를 다른 네트워크에 속한 수신지까지 전달하는 계층. LAN 간의 통신을 위한 기술들이 포함되어있다.
1-4. 전송 계층 - 신뢰성 있고 안정성 있는 전송을 해야 할 때 필요한 계층. 패킷에 송수신에 신뢰성을 더 할 수 있는 기술들과 
사용자 프로세스를 식별하기 위한 포트가 활용된다.
1-5. 세션 계층 - 통신을 주고받는 호스트의 응용 프로그램 간 연결 상태 즉, 세션을 관리한다.
1-6. 표현 계층 - 문자를 컴퓨터가 이해할 수 있는 코드로 변환하거나, 압축, 암호화를 한다.
1-7. 응용 계층 - 사용자와 사용자가 이용하는 응용 프로그램에 다양한 네트워크 서비스를 지원함. 사용자와 가장 맞닿아있음.
2. TCP/IP 모델(TCP/IP 4계층)
2-1. 네트워크 접근 계층 - 링크 계층, 네트워크 인터페이스 계층이라고도 불리며, OSI 모델의 데이터 링크와 유사하다.
2-2. 인터넷 계층 - OSI 모델의 네트워크 계층과 유사하다.
2-3. 전송 계층 - OSI 모델의 전송 계층과 유사하다.
2-4. 응용 계층 - OSI 모델의 세션 + 표현 + 응용 계층과 유사하다.
TCP/IP 모델에는 OSI의 물리 계층에 대한 하는 계층은 존재하지 않는다. 수신 과정에서는 응용 계층부터 역순으로
거치며, 송신 과정에서는 물리 계층부터 순서대로 거친다.

7강
 캡슐화란 계층별 프로토콜의 목적과 특징에 맞는 패킷의 헤더와 트레일러가 추가되는 과정을 의미한다. 각 계층에서 추가된
헤더와 기존의 페이로드가 합쳐져 다음 계층의 페이로드가 되는 걸 잊지 말자.
역 캡슐화는 가장 낮은 계층부터 프로토콜의 목적과 특징에 맞는 패킷의 헤더와 트레일러가 제거되는 과정을 의미한다. 상술하였듯
캡슐화 순서의 반대로 가장 낮은 계층부터 시작한다.

 PDU(Protocol Data Unit)란 각 계층에서 송수신되는 메세지의 단위를 뜻한다. 현재 계층의 PDU는 상위 계층의 데이터 + 
현재 계층의 프로토콜 헤더(데이터 링크 계층일 때에는 트레일러까지)이다. 각 계층별 PDU는 다음과 같다.

물리 계층 - 비트
데이터 링크 계층 - 프레임
네트워크 계층 - 패킷
전송 계층 - 세그먼트(TPC/IP), 데이터그램(UDP)
세션 계층 ~ 응용 계층 - 데이터

8강
 네트워크 참조 모델은 말 그대로 참조의 대상일 뿐 실질적인 행동은 취하지 않는다. 많은 서적 및 논문에도
각 계층과 계층의 이름은 다르게 서술하는 경우가 흔하며, 실질적으로 네트워크를 작동시키는 주체는
네트워크 참조 모델에 속한 프로토콜과 네트워크 장비임을 주의할 것.

9강
 트래픽이란 네트워크 내의	정보량을 뜻하며, 주로 특정 시점에 어떤 노드를 경유하는 정보량으로 측정할 수 있다.
과도한 트래픽은 과부하로 인한 네트워크 내의 성능 저하로 이어지며, 트래픽의 성능 지표로 다음과 같은 것들이 있다.
 
1. 처리율(Throughput). 각 단위 시간당 네트워크를 통해 실제로 전송되는 정보량을 의미하며 표현 단위는 다음의 4가지이다.

1-1. bps(bit/s) bits per second.
1-2. Mbps(Mbit/s) megabits per second.
1-3. Gbps(Gbit/s) gigabits per second.
1-4. pps(p/s) packets per second.

2. 대역폭(Bandwidth). 신호 처리 영역에서의 정의는 주파수의 범위를 의미한다. 컴퓨터 영역에서의 정의에서는 
단위 시간 동안 통신 매체를 통해 송수신할 수 있는 최대 정보량을 의미하며, bps, Mbps, Gbps 단위를 사용한다.
또한, 단순히 네트워크에서뿐만 아니라 다양한 하드웨어와 정보를 주고받을 수 있는 최대 역량을 나타내기 위한 지표로도 
범용성 있게 사용된다.

3. 패킷 손실(Packet Loss). 송수신되는 패킷이 손실된 상황. 손실된 패킷 수 혹은 전체 패킷 / 유실된 패킷(백분위)으로
사용된다.

10강
 네트워크 참조 모델의 계층을 나누어 학습하던 시절이 있었으나 기술이 발전하면서 인프라를 직접 코딩할 수 있게 되어
낮은 계층 역시 학습할 필요가 있다. 스킵하지 말자.

11강
 이더넷(Ethernet)이란 현대 LAN, 특히 유선 LAN 환경에서 가장 대중적으로 사용되는 기술이다. 다양한 통신 매체의
규격, 송수신되는 프레임의 형태, 프레임을 주고받는 방법 등이 정의된 기술. 유선 LAN 환경에서 물리 계층에서 사용되는
케이블이나 데이터 링크 계층에서 주고받는 프레임은 모두 이더넷의 형식을 따른다.

 이더넷은 IEEE(I 트리플 E) 802.3이라는 이름으로 국제 표준이 되었으며, 여기서 IEEE 802.3은 이더넷에 관련된 다양한
표준의 모음이다. 이더넷은 오늘날에도 발전 중이며, 802.3 뒤 알파벳을 사용하여 버전을 표현한다(ex 802.3u, 802.3ab).
이더넷의 버전에 따라 지원되는 네트워크 장비, 통신 매체, 전송 속도 등이 달라진다.

 상술한 대로 이더넷의 버전에 따라 통신 매체의 종류가 달라지나 그 이름을 칭할 때 IEEE 802.3u 케이블 등이 아닌
"전송 속도" BASE- "추가 특성"을 사용한다(ex 1000BASE-SX, 5GBASE-T 등). 각 부분을 나누어 설명하면 다음과 같다.

1. 전송속도
 전송속도는 숫자만 표기되어 있으면 Mbps, 숫자 뒤에 G가 붙는 경우 Gbps이다.
2. BASE
 BASE는 베이스밴드(BASEband)의 약자로, 변조 타입(modulation type)을 의미하는데 여기서 변조 타입은 비트 신호로
변환된 데이터를 통신 매체로 전송하는 방법이다.
3. 추가 특성
 통신 매체의 다양한 특성이 명시되어 있다. 
3-1. 전송 가능한 최대 거리 - 10BASE-2, 10BASE-5
3-2. 물리 계층 인코딩 방식 - 데이터가 비트 신호로 변환되는 방식.
3-3. 레인 수 - 한 번에 병렬로 옮길 수 있는 데이터의 수.
4. 통신 매체(케이블)의 종류(중요)
4-1. C - 동축 케이블.
4-2. T - 트위스티드 페어 케이블.
4-3. S - 단파장 광섬유 케이블.
4-4. L - 장파장 광섬유 케이블.

 이더넷은 지금도 발전 중이기에 그 속도에 따라 3가지로 분류된다.
1. 고속 이더넷 - 100Mbps가량의 속도를 지원하는 표준(ex 100Base-TX).
2. 기가비트 이더넷 - 1Gbps가량의 속도를 지원하는 표준(ex 1000BASE-T).
3. 10기가비트 이더넷 - 10Gbps가량의 속도를 지원하는 표준(ex 10GBASE-T).

12강
 이더넷 프레임이란 이더넷 네트워크에서 주고받는 프레임이다. 상위 계층 정보(페이로드) + 헤더 + 트레일러로 구성되며
캡슐화를 거쳐 송신되고, 역캡슐화를 거쳐 수신된다. 각 구성원을 자세히 살펴보면 다음과 같다.

1. 헤더 - 프리앰블, 수신지 MAC 주소, 송신지 MAC 주소, 타입/길이.
1-1. 프리앰블 
- 이더넷 프레임의 시작을 알리는 8바이트 크기의 정보이다.
- 첫 7바이트는 10101010 값을 가지고 마지막 바이트는 10101011 값을 가진다.
- 송수신지 간의 동기화를 위해 사용되는 정보일뿐 실질적인 송수신 정보는 없다.
1-2. 수신지 MAC 주소, 송신지 MAC 주소. 
- '물리적 주소'라고도 불리우며, 대부분 고유하고, 변경되지 않는 주소다.
- 네트워크 인터페이스(호스트가 통신 매체와 연결된 관문)마다 부여되는 각각 6바이트 길이의 주소이며 앞의 3바이트는 제조사 ID,
뒤의 3바이트는 식별자 ID이다. 
- LAN 내의 송수신지를 특정하며 일반적으로 NIC(Network Interface Controller) 장치가 네트워크 인터페이스 역할을 담당한다. 
네트워크 인터페이스의 수에 따라 한 컴퓨터에 여러개의 MAC 주소가 있을 수 있다.
1-3. 타입/길이
- 타입 혹은 길이를 담고 있는 2바이트 정보.
- 필드에 명시된 크기가 1500(16진수 05DC) 이하일 경우 프레임의 크기(길이)를 뜻한다.
- 필드에 명시된 크기가 1536(16진수 0600) 이상일 경우 프레임의 타입을 뜻한다. 타입은 이더타입이라고도 부르며 상위 계층에서
어떤 프로토콜을 사용하여 캡슐화 혹은 역캡슐화를 했는지를 나타낸다.
2. 페이로드 - 데이터.
- 상위 계층에서 전달받거나 전달해야 할 내용으로 최소 46, 최대 1500바이트의 크기를 가진다. 만약 46바이트보다 작다면
크기 맞추기용 데이터인 패딩(Padding)으로 채워지며, 보통 0으로 채워진다.
3. 트레일러 - FCS.
- Frame Check Sequence의 약자로, 오류 검출용 정보인 CRC(Cyclic Redundancy Check) 값을 사용한다.
- 헤더부터 페이로드의 값들을 이용한 해시값인듯 하며 송신측에서 만들어 트레일러에 보관후 수신측에서 다시 계산후 두 값을
비교하여 송수신간의 오류가 있었는지 확인한다.

13강
 NIC(Network Interface Controller)란 호스트와 통신 매체를 연결하고, MAC 주소가 부여되는 네트워크 장비이다.
케이블은 NIC에 연결되는 물리 계층의 유선 통신 매체이며 크게 트위스티드 페어 케이블, 광섬유 케이블로 나누어진다.

NIC
- 호스트와 유무선 통신 매체를 연결.
- 통신 매체 신호와 컴퓨터가 이해하는 정보 상호 변환.
- 호스트가 네트워크를 통해 송수신되는 정보는 NIC를 거치게 된다. 이때 네트워크 인터페이스(Network Interface) 역할을 수행한다.
- NIC는 MAC 주소를 인식할 수 있기 때문에 자신과 관련 없는 수신지 MAC 주소거나 FCS 필드를 토대로 잘못된 프레임이라면 폐기한다.
- 모든 정보들이 NIC를 거치기 때문에 NIC의 성능에 따라 네트워크 속도가 달라지게 된다.

 케이블
1. 트위스티드 페어 케이블
- 구리 선으로 전기 신호를 주고받는 통신 매체.
- 커넥터 + 케이블 본체로 구성되어있다.
- 구리 선은 노이즈에 민감하기 때문에 구리 선 주변을 감싸 노이즈를 감소시키는 차폐(Shield)라는 방식이 존재한다.
- 실드에 따른 트위스티드 페어 케이블은 다음과 같다.
1. STP(Shielded Twisted Pair) - 브레이드 실드로 감싼 케이블.
2. FTP(Foil Twisted Pair) - 포일 실드로 노이즈를 감소시킨 케이블.
3. UTP(Unshielded Twisted Pair) - 아무것도 감싸지 않은 구리 선만 있는 케이블.
- 더 자세하게는 XX/YTP의 형태로 분류를 하기도 한다.
- U : 실드 없음.
- S : 브레이드 실드.
- F : 포일 실드.
ex) S/FTP 케이블 - 외부는 브레이드 실드, 내부의 꼬인 각 구리 선들은 포일 실드.
    F/FTP 케이블 - 외부 내부 모두 포일 실드.
    SF/FTP 케이블 - 외부는 브레이드 실드와 포일 실드, 내부는 포일 실드.
    U/UTP 케이블 - 외부, 내부 모두 아무것도 감싸지 않은 케이블.
- 카테고리에 따라서도 분류가 가능하며 카테고리가 높을수록 지원 가능한 대역폭이 늘어나 더 빠른 전송이 가능하다.
ex) Cat5 ~ Cat8

2. 광섬유 케이블
- 빛(광신호)을 이용해 정보를 주고받는 케이블.
- 전기 신호를 이용하는 케이블에 비해 속도도 빠르고, 먼 거리까지 전송이 가능.
- 잡신호로부터 간섭받는 영향도 적으므로 대륙 간 네트워크 해저 연결에도 사용.
- 커넥터 + 케이블 본체로 구성되어있다. 다만 하나의 커넥터만 사용하는 트위스티드 페어 케이블과는 달리
다양한 종류의 커넥터를 사용한다.
- 머리카락과 같은 형태의 여러 개의 광섬유로 구성되어 있으며 이 광섬유가 빛을 운반하는 매체가 된다.
- 광섬유 중심에는 실질적으로 빛이 흐르는 코어가 존재하며, 빛을 가두는 클래딩으로 감싸져 있다.
- 코어에 지름에 따라서 다음과 같이 2가지로 나누어진다.

1. 싱글 모드(SMF, Single Mode Fiber)
- 코어의 지름이 8 ~ 10㎛(좁다).
- 코어의 지름이 작으면 빛의 이동 경로가 하나 이상을 갖기 어려워(지름이 작아 반사가 적음) 상태가 하나이다.
- 신호 손실이 적기에 장거리 전송에 적합하다.
- 다중 형식에 비해 일반적으로 비용이 많이 듦.
- 싱글 상태 케이블은 파장이 긴 장파장의 빛을 사용.
- 케이블의 본체는 대부분 노란색과 파란색이다.

2. 멀티 모드(MMF, Multi Mode Fiber)
- 코어의 지름이 50 ~ 62.6㎛로 싱글 상태보다 크다.
- 빛이 여러 경로로 이동할 수 있기에 상태가 여러 개다.
- 싱글 상태보다 신호 손실이 클 수 있기에 장거리 전송에는 부적합하다.
- 다중 형식 케이블은 싱글 상태에 비해 단파장의 빛을 사용한다.
- 케이블의 본체는 주황색과 아쿠아색이다.

14강
 물리 계층과 데이터 링크 계층의 장비.

물리 계층 - 허브(오늘날 잘 쓰이지 않는다.)
데이터 링크 계층 - 스위치.

반이중(Half Duplex) 모드 - 1차원 도로처럼 송수신을 번갈아 가면서 하는 방식.
전이중(Full Duplex) 모드 - 양방향 통신이 가능한 방식.

 물리 계층에는 주소 개념이 없다. 단지 호스트와 통신 매체 간의 연결과 데이터의 송수신이 이루어 질 뿐이기에
정보에 대한 어떠한 조작이나 판단도 없다.
반면에 데이터 링크 계층에는 MAC 주소가 존재함으로 송수신지를 특정할수도 있고 정보에 대한 조작도 가능하다.

물리 계층의 장치, 허브.
- 여러대의 호스트를 연결하는 장치이며, 리피터 허브 혹은 이더넷 허브라고도 부른다.
- 포트라는 부분에 커넥터들을 연결하여 사용되며 오늘날에는 거의 쓰이지 않는다.
- 전달받은 신호를 연결된 다른 모든 포트로 그대로 돌려보낸다. 물리 계층에 주소라는 개념이 존재하지 않기 때문이다.
이후 데이터 링크 계층에서 자신과 상관없는 프레임(데이터)들은 폐기를 한다. 또한, 이러한 방식은 불필요한 트래픽이
너무 많아진다.
- 반이중 모드다.

참고) 또 다른 물리 계층 장비, 리피터(Repeater)
- 허브 이외에 물리 계층의 대표적인 장비.
- 전기 신호가 감소하거나 왜곡되는 것을 방지하기 위해 전기 신호를 증폭시켜 주는 장비.
- 리피터 역시 물리 계층의 장비이므로 어떠한 조작이나 판단없이 신호를 증폭시키기만 한다.
- 허브는 리피터의 기능을 포함하고 있는 경우가 많음.

허브의 특징이 야기하는 문제, 충돌(Collision)
- 동시에 허브에 신호를 송신하면 충돌이 발생한다.
- 허브에 호스트가 많이 연결되어 있을수록 충돌 발생 가능성이 높다.
- 충돌이 발생할 수 있는 영역을 콜리전 도메인이라고 하며, 허브에 연결된 모든 호스트가 
같은 콜리전 도메인에 속한다.
- 콜리전 도메인을 줄이기 위해서는 데이터 링크 계층의 장비인 스위치를 사용하거나
CSMA/CD 프로토콜을 사용하여야 한다.

CSMA/CD(Carrier Sense Multiple Access with Collision Detection)
- 반이중 이더넷 네트워크에서 충돌을 방지하는 대표적인 프로토콜이자, 반이중 이더넷을 대표하는
송수신 방법.  
1. 캐리어 감지 - 통신 매체의 현재 사용 가능 여부 검사를 한다. 메세지를 송신하기 전 현재 전송중인 것이
있는지를 먼저 확인한다.
2. 다중 접근 - 그럼에도 불구하고 복수의 호스트가 부득이하게 동시에 네트워크에 접근시 충돌이 발생한다.
3. 충돌 검출 - 전송 중단, 충돌 발생을 알리는 잼 신호(Jam Signal)을 보낸다. 그 이후 임의(랜덤한)의 시간 동안
기다린 뒤에 재전송을 한다.

15강
 스위치
- 허브와는 달리 MAC 주소라는 개념이 존재하기에 수신지 호스트에만 프레임 전달 가능.
- 전이중 모드를 지원하기에 CSMA/DC가 필요하지 않고 콜리전 도메인도 대폭 감소한다.

 스위치의 기능
1. MAC 주소 학습 기능 - 특정 포트와 해당 포트에 연결된 호스트의 MAC 주소를 기억하여 전달받은 신호를 원하는 포트로만 보낸다.
2. 포트와 포트에 연결된 호스트의 MAC 주소를 MAC 주소 테이블에 저장하여 사용함.
3. 포트별로 콜리전 도메인이 나누어지기에 충돌 위험 감소.
4. 스위치의 VLAN 기능 - 논리적으로 LAN을 분리하는 가상의 LAN, VLAN 구성 가능.

 스위치의 MAC 주소 학습 기능
1. MAC 주소 학습 - 프레임 내 '송신지 MAC 주소' 필드를 바탕으로 이루어진다. 최초로 어떤 포트에서 스위치에
데이터가 수신되었을때 스위치는 MAC 주소 테이블에 해당 송신지의 주소를 채워넣는다.
2. 수신지의 포트를 알수 없기에 모든 포트로 수신하는 과정(플러딩, Flooding)을 거치고 송신지에서 표시한 수신지를 제외한
나머지 호스트는 이 데이터들을 무시한다.
3. 수신지에서 스위치로 응답 프레임을 전송하여 수신지의 MAC 주소가 스위치의 MAC 주소 테이블에 저장된다.
4. 그 이후로는 다른 호스트가 연결된 포트로는 데이터를 보내지 않도록 필터링(Filtering)을 하게 되며,
수신지가 연결된 포트로만 프레임을 포워딩(Forwarding)하게 된다.
5. 오직 스위치만 MAC 주소 테이블을 저장함

 정리하자면, 처음에는 MAC 주소 테이블에 각 포트와 MAC 주소의 연결이 이뤄지지 않아 어쩔수 없이 모든 포트로
프레임을 수신하는 플러딩을 하게 되고, 진짜 수신지에서는 프레임을 받아 응답 프레임을 보내고, 나머지 호스트는
해당 프레임을 폐기하면서 MAC 주소 테이블에 송신자와 수신지의 포트와 MAC 주소의 정보가 저장된다. 그 이후로는
필터링과 포워딩을 통해 트래픽을 줄이게 된다.

 에이징 - 어떤 MAC 주소와 연결된 포트가 '송신지로써' 일정 시간 동안 프레임을 보내지 않는다면 해당 포트의 항목은
MAC 주소 테이블에서 삭제된다.

 VLAN(Virtual LAN)
- 한대의 물리적 스위치를 여러 대의 스위치가 있는 것처럼 논리적인 단위로 LAN을 나누어 구획한다.
- 하나의 네트워크에 존재하는 호스트가 나누어지기 때문에 불필요한 트래픽(허브, 스위치의 플러딩)으로 인한 성능 저하 방지.
- 사용자가 임의로 나누는 듯 하다.
- 서로 다른 네트워크로 간주하며, 브로트캐스트 도메인이 달라진다.

VLAN의 종류는 다음과 같이 2가지가 있다.

1. 포트 기반 VLAN(Port Based VLAN)
- 정적 VLAN이라고도 불린다.
- 스위치의 포트가 VLAN을 결정하는 방식.
- 특정 포트에 VLAN을 할당한 뒤, 해당 포트에 호스트를 연결하여 VLAN에 참여.
(ex 1번 ~ 5번 포트는 VLAN1, 6, 8, 9번 포트는 VLAN2, 7, 10, 11번 포트는 VLAN3)
2. MAC 기반 VLAN(MAC Based VLAN)
- 동적 VLAN이라고도 불린다.
- 직접 MAC를 스위치에 저장시키며 MAC를 기준으로 VLAN이 나누어진다. 
- 송수신하는 프레임 속 MAC 주소가 호스트가 속할 VLAN을 결정하는 방식.

16강.
 케이블 실습으로 대체.

17강.
 데이터 링크 계층의 한계.
1. 물리 계층과 데이터 링크 계층만으로는 다른 네트워크까지의 도달 경로를 파악하기 어려움.
- 네트워크 계층에서 라우팅(Routing, 패킷이 이동할 최적의 경로를 결정하는 것)을 통해서 알수 있다.
- 라우팅을 수행하는 대표적인 장비인 라우터(Router)가 있다.
2. MAC 주소만으로는 모든 네트워크에 속한 모든 호스트의 위치를 특정하기 어려움.
- MAC 주소와 IP 주소는 함께 사용되고, 기본적으로 IP 주소를 우선 활용.

 MAC 주소와 IP 주소의 비교.

 IP주소 
- 택배의 수신지 역할.
- 논리 주소.
- 유동적으로 할당되며, 자동으로 할당받거나 사용자가 직접 할당.

 MAC 주소
- 택배의 수신인 역할.
- 물리 주소.
- NIC마다 할당되는 고정된 주소.

18강.
 네트워크 계층의 핵심, 인터넷 프로토콜(Internet Protocol)
- 물리 계층, 데이터 링크 계층의 한계를 극복하는 프로토콜.
- IP 버전 4(IPv4)와 IP 버전 6(IPv6)이 있다.

 IP의 공식적인 두 기능.
1. 주소 지정(IP Addressing).
- IP 주소 (IPv4)를 바탕으로 송수신 대상을 지정하는 것을 의미.
- 4바이트로 하나의 주소를 표현.
- 숫자당 8비트로 표현 : 0 ~ 255 범위 안에 있는 네 개의 10진수로 표기.
- 각 숫자는 점(.)으로 구분하며 점으로 구분된 8비트 10진수를 옥텟(Octet)이라 한다.
2. 단편화(IP Fragmentation).
- 전송하고자 하는 패킷의 크기를 MTU 이하의 복수의 패킷으로 나누는 것.
2-1. MTU(Maximum Transmission Unit)
 - 한 번에 전송 가능한 IP 패킷의 최대 크기.
 - IP 패킷(네트워크 계층의 데이터)의 헤더도 MTU 크기에 포함.
 - 일반적인 MTU 크기는 1500 바이트, MTU 크기 이하로 나누어진 패킷은 수신지에 도착후 다시 재조합된다.

 IPv4 패킷의 핵심 필드
1. 식별자(Identifier).
- 패킷에서 할당된 번호.
- 쪼개져서 도착한 IPv4 패킷들이 어떤 메세지에서 쪼개졌는지를 알기 위해 사용.
2. 플래그(Flag).
- 3개의 비트로 구성.
- 첫번째 비트는 항상 0으로 사용되지 않는다.
- DF 비트(Don't Fragment) - IP 단편화의 수행 여부를 나타내는 필드. 1이라면 단편화 x, 0이라면 단편화 o.
- MF 비트(More Fragment) - 단편화된 패킷이 더 있는지를 나타내는 필드. 1이라면 단편화된 패킷이 더있음.
0이라면 단편화된 패킷이 더이상 존재하지 않음을 뜻함.
3. 단편화 오프셋(Fragment Offset).
- 초기 데이터에서 몇 번째로 떨어진 패킷인지를 나타냄.
- 단편화되어 전송되는 패킷들은 수신지에 순서대로 도착하지 않을 수 있음.
- 수신지가 패킷들을 순서대로 재조합하려면 단편화된 패킷이 초기 데이터에서 몇 번째에 해당하는 패킷인지 알아야함.
4. TTL(Time To Live).
- 패킷의 수명.
- 무의미한 패킷이 네트워크상에 지속적으로 남아있는 것을 방지하기 위해 존재.
- 패킷이 하나의 라우터를 거칠 때마다 TTL이 1 감소, TTL 값이 0으로 떨어진 패킷은 폐기.
- 홉(Hop)이란 패킷이 호스트 또는 라우터로 한 번 이동하는 것. 즉, 홉마다 TTL은 1씩 감소한다.
5. 프로토콜.
- 상위 계층의 프로토콜이 무엇인지를 나타내는 필드. 데이터 링크 계층 패킷의 타입/길이와 비슷하다.
6. 송신지 IP 주소.
- 4바이트 송신지 IP 주소.
7. 수신지 IP 주소.
- 4바이트 수신지 IP 주소.

 IPv6
- IPv6은 16바이트로 주소를 표현할 수 있고, 콜론(:)으로 구분된 8개 그룹의 16진수로 표기
- 이론적으로 할당 가능한 IPv6 주소는 2의 128제곱으로 사실상 무한에 가까운 수 할당 가능

 IPv6 패킷의 핵심 필드
1. 다음 헤더(Next Header)
- 상위 계층의 프로토콜 또는 확장 헤더를 가리키는 필드
- 확장 헤더란 IPv6에 있는 추가 헤더로 기본 헤더와 페이로드 사이에 위치하며 또 다른 확장 헤더를 가질 수도 있다
2. 홉 제한(Hop Limit)
- IPv4 패킷의 TTL 필드와 동일하다
- 패킷의 수명을 나타내는 필드
3. 송신지 IP 주소
- IPv6 주소를 통한 송신지 지정
4. 수신지 IP 주소
- IPv6 주소를 통한 수신지 지정

 IPv6의 단편화
- IPv6는 단편화 확장 헤더를 통해 단편화가 이루어짐
- 단편화 확장 헤더에도 다음 헤더 필드가 있음
- 예약됨과 예약 필드는 0으로 설정되어 사용되지 않음
- 단편화 오프셋은 전체 메세지에서 현재 단편화된 패킷의 위치(IPv4의 단편화 오프셋과 동일)
- M 플래그는 1일 경우 더 많은 단편화된 패킷이 있음을, 0일 경우 마지막 패킷임을 알림(IPv4의 MF 플래그 필드와 동일)
- 식별자는 동일한 메세지에서부터 단편화된 패킷임을 식별함(IPv4의 식별자 필드와 동일)

19강
 ARP(Address Resolution Protocol)
- IP 주소를 통해 MAC 주소를 알아내는 프로토콜. 동일 네트워크 내에 있는 송수신 IP 주소를 통해 MAC 주소를 알아낼 수 있음
- MAC 주소 테이블과는 달리 호스트, 라우터 등 모두 저장함
- 동일 네트워크 내에 있는 호스트의 MAC를 알아야할때 사용됨을 주의할 것
- 다른 네트워크에 존재하는 호스트의 MAC를 찾을때에는 네트워크 별로 반복하여 ARP 요청 - 응답이 진행된다
- 송신 호스트가 직접적으로 도달할수 있는 목적지의 주소를 저장한다. 같은 네트워크 안에 있는 수신 호스트일 경우에는
그 호스트의 MAC 주소를, 다른 네트워크 안에 있는 수신 호스트는 라우터에게 맡기기에 라우터의 MAC 주소를 저장한다.
1. ARP 요청
- 송신 호스트가 브로드캐스트 메시지 전송
- 브로드캐스트 메시지는 ARP 요청이라는 ARP 패킷
2. ARP 응답
- 수신 호스트 외에 나머지 호스트는 자신의 IP 주소가 아니므로 브로드캐스트 메세지를 무시한다
- 수신 호스트는 자신의 MAC 주소를 담은 유니캐스트 메세지를 송신 호스트에 전송
- 유니캐스트 메시지는 ARP 응답이라는 ARP 패킷이며, 송신 호스트는 수신 호스트의 MAC 주소를 알게 됨
3. ARP 테이블 갱신
- ARP 요청 - 응답을 통해 알게 된 IP 주소와 MAC 주소의 연관 관계를 각 호스트마다 ARP 테이블에 저장한다
- ARP 테이블 항목은 일정 시간이 지나면 삭제, 임의 삭제도 가능
- ARP 테이블에 등록된 호스트에 대해선 ARP 요청을 더이상 보낼 필요가 없다

 ARP 패킷
- ARP 요청, ARP 응답 과정에서 송수신되는 패킷이며 구조는 다음과 같다
1. 오퍼레이션 코드(Opcode, Operation Code) 
- ARP 요청의 경우 1, ARP 응답의 경우 2
2. 송신지 및 수신지 하드웨어 주소(MAC 주소)
3. 송신지 및 수신지 프로토콜 주소(IP 주소)

20강.
 IP 단편화 추가
- IP 단편화는 되도록 하지 않는 편이 좋다
- 패킷이 쪼개질때마다 추가로 헤더 역시 생성되기 때문에 불필요한 트래픽 증가와 대역폭이 낭비된다
- 쪼개진 IP 패킷들을 하나로 합치는 과정에서 발생하는 부하도 성능 저하 요소

 IP 단편화 피하기
- IP 패킷을 주고받는 모든 노드가 IP 단편화 없이 주고 받을 수 있는 최대 크기만큼만 전송하여 단편화를 피해야한다.
- IP 단편화 없이 주고 받을 수 있는 최대 크기를 경로 MTU(Path MTU)라고 한다
- 경로 MTU를 계산하여 그만큼씩 데이터를 송수신하여 IP 단편화를 회피해야 한다
- 실제로도 IPv4의 대부분 DF비트가 1로 세팅되어 있어 단편화는 자주 일어나지 않는다

21강.
 IP 주소 지정
- 주소 지정은 IP 주소로 이루어짐
- IP 주소는 크게 네트워크 주소와 호스트 주소로 구성된다
1. 네트워크 주소
- 호스트가 속한 특정 네트워크를 식별
- 네트워크를 표현하는 부분
2. 호스트 주소
- 어떤 네트워크안에 특정 호스트를 식별
- 호스트를 표현하는 부분

- IP 주소의 네트워크 주소와 호스트 주소의 비중은 유동적으로 달라진다
- 호스트 주소 공간이 무조건 크면 할당되지 않은 다수의 IP가 낭비되고, 무조건 작으면 부족해진다
- 이러한 고민을 해결하기 위해 생겨난 개념이 IP 주소의 클래스(Class)이다

 클래스
- 네트워크 크기에 따라 IP 주소를 분류하는 기준
- 클래스풀 주소 체계(Classful Addressing)이라 부르며, 클래스를 기반으로 IP 주소를 관리하는 주소 체계
- 필요한 호스트 IP 개수에 따라 클래스를 달리 선택하여 네트워크 크기를 조절한다
- 호스트 주소가 3옥텟인 A클래스부터 E클래스까지 존재하나, D와 E클래스는 각각 멀티캐스트를 위한
클래스로써 특수한 목적을 지니고 있기에 사실상 호스트 주소가 1옥텟인 C클래스까지만 사용한다

1. A클래스 
- B와 C클래스에 비해 할당 가능한 호스트 주소의 수가 많음
- 네트워크 주소는 비트 '0'으로 시작하는 1옥텟, 호스트 주소는 3옥텟으로 구성
- 이론상 2의 7제곱(128)개의 A클래스 네트워크 존재 가능(첫번째 비트가 0이기에 나머지 7개의 비트를 사용)
- 각 네트워크에 2의 24제곱(대략 1600만개)의 호스트 주소 할당 가능
- 가장 처음 옥텟의 주소가 0 ~ 127일 경우 A클래스 주소임을 짐작할 수 있음
2. B클래스
- 네트워크 주소는 비트 '10'으로 시작하는 2옥텟, 호스트 주소도 2옥텟으로 구성
- 이론상 2의 14제곱(16000개 가량)개의 B클래스 네트워크 존재 가능
- 각 네트워크에 2의 16제곱(65000개 가량)개의 호스트 주소 할당 가능
- 가장 처음 옥텟의 주소가 128 ~ 191일 경우 B클래스 주소임을 짐작할 수 있음
3. C클래스
- 네트워크 주소는 비트 '110'으로 시작하는 3옥텟, 호스트 주소는 1옥텟으로 구성
- 이론상 2의 21제곱(200만개 가량)개의 C클래스 네트워크 존재 가능
- 각 네트워크에 2의 8제곱(256개 가량)개의 호스트 주소 할당 가능
- 가장 처음 옥텟의 주소가 192 ~ 223일 경우 C클래스 주소임을 짐작할 수 있음

 클래스풀 주소 체계
- 호스트의 주소 공간을 모두 사용할 수 있는 것은 아니다
- 호스트 주소가 전부 0인 IP 주소는 해당 네트워크 자체를 의미하는 네트워크 주소로 사용된다
- 호스트 주소가 전부 1인 IP 주소는 브로드캐스트 주소로 사용된다

 클래스별 할당 가능한 주소의 개수 정리
1. A클래스 
- 초기 비트는 0
- 네트워크 주소 비트 8비트, 호스트 주소 비트는 24비트
- 할당 가능한 네트워크 수는 2의 7제곱(초기 비트 1개 제외)
- 할당 가능한 호스트의 수는 2의 24제곱 - 2(호스트가 모두 0일때와 1일때의 2가지 경우 제외)
2. B클래스 
- 초기 비트는 10
- 네트워크 주소 비트 16비트, 호스트 주소 비트는 16비트
- 할당 가능한 네트워크 수는 2의 14제곱(초기 비트 2개 제외)
- 할당 가능한 호스트의 수는 2의 16제곱 - 2(호스트가 모두 0일때와 1일때의 2가지 경우 제외)
3. C클래스 
- 초기 비트는 110
- 네트워크 주소 비트 24비트, 호스트 주소 비트는 8비트
- 할당 가능한 네트워크 수는 2의 21제곱(초기 비트 3개 제외)
- 할당 가능한 호스트의 수는 2의 8제곱 - 2(호스트가 모두 0일때와 1일때의 2가지 경우 제외)

22강
 클래스리스 주소 체계(Classless Addressing)
- 클래스별 네트워크 크기가 고정되어 있어 여전히 낭비되는 IP 주소가 많을 수 있다
- 클래스별 네트워크 크기가 고정되어 있어 사전에 정해진 크기 외의 다른 크기 네트워크 구성 불가능
- 클래스 개념 없이 클래스에 구애받지 않고 네트워크의 영역을 나누고 호스트에게 IP 주소 공간을 할당하는 방식
- 클래스풀 주소 체계보다 더 유동적이고 정교한 네트워크 구획 가능
- 오늘날 주로 사용되는 방식이다

 서브넷 마스크(Subnet Mask)
- 클래스 없이 IP 주소의 네트워크 주소, 호스트 주소를 구분하는 수단
- IP 주소상에서 네트워크 주소는 1, 호스트 주소는 0으로 표기한 비트열

 서브네팅(Subnetting)
- 서브넷 마스크를 이용해 클래스를 원하는 크기로 더 잘게 쪼개어 사용하는 것
- 서브넷 마스크로 네트워크 주소와 호스트 주소를 구분 짓는 방법
- IP 주소와 서브넷 마스크를 비트 AND 연산한 결과가 네트워크 주소가 된다

 서브넷 마스크 크기 : CIDR 표기법(Classless Inter-Domain Routing notation)
- IP 주소/서브넷 마스크상의 1의 개수 형식으로 표기(왼쪽부터 전부채워진 N개)
ex) 192.168.219.103/24

23강
 IP 주소의 분류
1. 공인 IP 주소(Public IP Address)
- 전 세계에서 유일한 고유 IP 주소
- 네트워크 간의 통신, 이를테면 인터넷을 이용할 때 사용하는 IP 주소
- 공인 IP 주소는 ISP나 공인 IP 주소 할당 기관을 통해 할당
2. 사설 IP 주소(Private IP Address)
- 사설 네트워크에서 사용하기 위한 IP 주소
- 사설 IP 주소로 사용하도록 특별히 예약된 IP 주소 공간
- 사설 IP 주소의 할당 주체는 일반적으로 라우터(공유기)
- 사설 IP 주소는 호스트가 속한 사설 네트워크에서만 유효한 주소
- 얼마든지 다른 네트워크상의 사설 IP 주소와 중복 가능
- 일반적으로 네트워크 간의 통신은 사설 IP 주소가 아닌 공인 IP 주소를 통해 이루어짐
- 사설 IP 주소는 그 호스트가 속한 네트워크 내에서만 사용이 가능하며 다른 네트워크(인터넷 등)과 통신을
할때에는 공인 IP 주소를 이용해야 한다

 NAT(Network Address Traslation)
- IP 주소 변환 기술로써, 주로 사설 IP 주소(네트워크 내부)와 공인 IP 주소(네트워크 외부)를 변환
- 대부분의 라우터와 가정용 공유기는 NAT 기능을 내장하고 있다
- 사설 네트워크의 패킷 속 사설 IP 주소는 공유기를 거쳐 공인 IP 주소로 변경
- 외부 네트워크의 패킷 속 공인 IP 주소는 공유기를 거쳐 사설 IP 주소로 변경

24강
 정작 IP 주소와 동적 IP 주소
1. 정적 할당
- 호스트에 직접 IP 주소를 부여하는 방식
- 이렇게 할당된 IP 주소가 정적 IP 주소(Static IP Address)
- 일반적으로 부여하고자 하는 IP 주소, 서브넷 마스크, 게이트웨이(라우터) 주소, DNS 주소를 입력
- 호스트의 수가 많아질 경우 관리 곤란
- 의도치 않게 잘못된 IP 주소를 입력할 수도 있고, 중복된 IP 주소를 입력할 수도 있음
2. 동적 할당
- IP 동적 할당에 사용되는 대표적인 프로토콜 DHCP(Dynamic Host Configuration Protocol)을 활용해
자동으로 할당하는 방식
- 이렇게 할당된 IP 주소를 동적 IP 주소(Dynamic IP Address)라고 한다

 게이트웨이
- 게이트웨이란 일반적으로 서로 다른 네트워크를 연결하는 하드웨어/소프트웨어적 수단
- 기본 게이트웨이란 호스트가 속한 네트워크 외부로 나가기 위한 기본적인 첫 경로이며
보통 라우터(공유기)의 주소를 의미하는 경우가 많다
- 상술한 게이트웨이라는 용어는 기본 게이트웨이(라우터 혹은 공유기의 주소)를 의미한다

 DHCP를 통한 IP 주소 할당
- 클라이언트와 DHCP 서버 간 메세지 송수신을 통해 할당이 이루어짐
- 클라이언트는 IP 주소를 할당받고자 하는 호스트
- DHCP 서버는 호스트에게 IP 주소를 제공하는 호스트
- DHCP 서버의 역할은 일반적으로 라우터(공유기)가 수행한다
- 특정 호스트에 DHCP 서버 기능을 추가할 수도 있음
- DHCP 서버는 클라이언트에게 할당 가능한 IP 주소 목록을 관리하다, 클라이언트 요청시 IP 주소를 담당
- DHCP로 할당받은 동적 IP 주소는 사용할 기간(임대 기간)이 정해진다
- 일반적으로 수 시간에서 수 일이며, 임대 기간이 끝난 IP 주소는 다시 DHCP 서버로 반납한다

 IP 주소 할당 과정에서 주고받는 메시지
1. DHCP Discover
- DHCP 서버를 찾는 메시지로써 브로드캐스트로 전송한다
- 클라이언트는 아직 IP 주소를 할당받지 못한 상황으로 송신지 IP 주소는 0.0.0.0/8으로 설정
2. DHCP Offer
- 클라이언트에게 할당 가능한 IP 주소 정보를 제안하는 메시지
- 할당 가능한 IP 주소, 서브넷 마스크, 임대 기간 등의 정보 포함
3. DHCP Request
- DHCP Offer 메시지에 대한 응답
- 아직까지 IP 할당을 받지 못하였기에 마찬가지로 브로드캐스트로 전송한다
4. DHCP ACK
- 최종 승인과 같은 메시지
- DHCP ACK 메시지를 수신한 클라이언트는 이제 할당받은 IP 주소를 자신의 IP 주소로 설정 후
임대 기간 동안 IP 주소 사용
- 원칙적으로는 임대 기간이 끝나면 IP 주소를 DHCP 서버로 반납하고 상술한 4단계를 거쳐서
IP 주소 재할당을 받아야하지만 임대 갱신을 할수도 있다

 임대 갱신(Lease Renewal)
- IP 주소 임대 기간이 끝나기 전에 임대 기간을 연장하는 것
- 임대 기간이 끝나기 전에 기본적으로 두 차례 자동으로 수행
- 자동 임대 갱신이 모두 실패하면 그때 IP 주소 반납

25강
 특수한 목적을 위해 예약된 IP 주소
1. 127.0.0.1 
- 루프백 주소(Loopback Address), 로컬 호스트(Local Host)
- 자기 자신을 가리키는 특별한 주소
- 루프백 주소로 전송된 패킷은 자기 자신에게 돌아옴
- 부메랑 역할을 수행하는 주소로써, 테스트나 디버깅 용도로 사용
2. 0.0.0.0/8
- 호스트가 IP 주소를 할당받기 전에 임시로 할당되는 IP 주소
- ex) DHCP Discover 메세지를 전송하는 시점의 클라이언트 IP 주소
- 특별히 지칭할 IP 주소가 없을 때 사용하는 IP 주소
- 호스트 입장에서 마땅히 자신을 지칭할 IP 주소가 없을 때
3. 0.0.0.0/0
- 0.0.0.0/8과 유사하지만 다른 의미를 지니는 주소
- 모든 임의의 IP 주소
- 주로 라우팅에서 디폴트 라우트(Default Route)를 나타내기 위해 사용
- 디폴트 라우트란 패킷을 어떤 IP 주소로 전달할지 어려울 경우 기본적으로 패킷을 전달할 경로
- 어디로 패킷을 전달해야 할지 명확하지 않으면 여기로 패킷을 이동시켜라 

26강
 데이터 링크 계층의 한계
- 물리 계층과 데이터 링크 계층만으로는 LAN을 넘어서 통신하기 어려운 두 가지 이유
1. 다른 네트워크까지의 도달 경로를 파악하기 어려움
2. 모든 네트워크에 속한 모든 호스트의 위치를 특정하기 어려움
3. 라우터(Router)
- 라우팅을 수행하는 대표적인 장비
4. 라우팅(Routing)
- 패킷이 이동할 최적의 경로(최소 홉)를 결정하는 것

 네트워크 간 통신을 가능케 하는 네트워크 계층의 장비
- 네트워크 간 통신 과정에서 패킷은 여러 라우터를 거쳐서 다양한 경로로 이동할 수 있음
- 패킷은 여러 대의 라우터를 거쳐 수신지까지 이동

 라우팅 테이블
- 특정 수신지까지 도달하기 위한 정보를 명시한 표와 같은 정보
- 라우터는 라우팅 테이블을 참고하여 수신지까지의 도달 경로를 판단

 라우팅 테이블에 포함된 정보
- 라우팅 방식에 따라, 호스트의 환경에 따라 달라질 수 있음
1. 수신지 IP 주소와 서브넷 마스크
- 최종적으로 패킷을 전달할 대상
2. 다음 홉(Next Hop)
- 최종 수신지까지 가기 위해 다음으로 거쳐야 할 호스트의 IP 주소나 인터페이스
- 게이트웨이라고 명시되기도 함
3. 네트워크 인터페이스
- 패킷을 내보낼 통로
- 인터페이스(NIC) 이름이 직접 명시되거나 인터페이스에 대응하는 IP 주소 명시
4. 메트릭(Metric)
- 해당 경로로 이동하는 데에 드는 비용
- 라우팅 테이블의 여러 경로 중 메트릭이 낮은 경로를 선호
- 현재 정점이 여러개의 NIC를 가지고 있을때 어떤 NIC를 통해 패킷을 내보내야 하는지에 대한 정보

 디폴트 라우트
- 0.0.0.0/0
- 라우팅 테이블에 없는 수신지의 패킷을 받았을때 그 패킷을 내보낼 경로
- 예외 발생시 패킷을 보낼 수신지를 뜻한다
- 일반적으로 기본 게이트웨이 주소가 된다
- 기본 게이트웨이란 네트워크 외부로(LAN 밖으로) 나아가기 위한 첫 경로, 보통 라우터/공유기 주소가 된다
- 라우팅 테이블에 등록되지 않은 예외적인 패킷들을 기본 게이트웨이(라우터/공유기)에게 전달한다

27강
 정적 라우팅과 동적 라우팅
- 정적 라우팅과 동적 라우팅은 IP 주소를 할당하는 방법과 유사함
1. 정적 라우팅 
- 수동으로 구성된 라우팅 테이블 항목을 통해 수행되는 라우팅
- 정적 IP 할당과 비슷하게 네트워크의 규모가 커지고 관리해야 할 라우터가 늘어나면 입력 실수나
예상치 못한 경우에 경로 우회가 어렵다
2. 동적 라우팅
- 자동으로 라우팅 테이블 항목을 만들고, 이를 이용하여 라우팅을 수행함
- 라우터끼리 자신들의 정보를 교환하여 패킷이 이동할 최적의 경로를 찾기 위한 라우팅 프로토콜(Routing Protocol)을
사용한다
- 동적 라우팅을 사용하면 라우팅 테이블 항목이 수시로 변할 수 있음
- 라우팅 테이블 항목을 수동으로 입력할 필요 없음
- 네트워크 경로상에 문제가 발생했을 때 이를 우회할 수 있게 경로가 자동으로 갱신

 라우터들의 집단 네트워크, AS(Autonomus System)
- 한 회사나 단체에서 관리하는 라우터 집단
- 라우팅 프로토콜의 기준, 단위가 된다
- AS마다 인터넷상에서 고유한 AS번호(ASN; Autonomus System Number)가 할당
- AS번호는 사설 IP주소처럼 사설 AS번호도 있지만, 일반적으로 AS번호는 전세계에서 고유한 AS번호를 지칭
- 한 AS내에는 다수의 라우터가 존재
- 라우터들은 AS내부에서만 통신할 수도 있고, AS외부와 통신할 수도 있음
- AS외부와 통신할 경우 AS경계에서 AS내외로 통신을 주고받을 수 있는 특별한 라우터인 AS 경계 라우터
(ASBR; Autonomus System Boundary Router)를 이용한다

 라우팅 프로토콜
- 라우터끼리 자신들의 정보를 교환하며 패킷이 이동할 최적의 경로를 찾기 위한 프로토콜
- 라우팅 프로토콜의 종류
1. IGP(Interior Gateway Protocol)
- AS 내부에서 수행 ex) RIP, OSPF
2. EGP(Exterior Gateway Protocol)
- AS 외부에서 수행 ex) BFP

 대표적인 IGP
1. RIP
- 최적의 경로를 선정하는 과정에서 거리 벡터를 사용
- 거리는 패킷이 경유한 라우터의 수, 즉 홉의 수를 의미
- 특정 수신지까지 도달하기 위해 홉 수가 가장 적은 경로를 최적의 경로라고 판다
- 홉 수가 적을수록 라우팅 테이블상의 메트릭 값도 작아짐
- 주기적으로 인접 라우터끼리 경로 정보 교환, 라우팅 테이블 갱신, 특정 수신지까지의 홉 수 계산
2. OSPF
- 최적의 경로를 선정하는 과정에서 링크 상태를 사용
- RIP처럼 주기적으로 라우터 간 통신이 수행되지 않고 네트워크 구성 변경 시 라우팅 테이블이 갱신된다
- 현재 네트워크 구성을 마치 지도처럼 그린 뒤, 최적의 경로를 선택
- 현재 네트워크의 상태(링크 정보)를 링크 상태 데이터베이스(Link State Datebase)에 저장
- 라우터들의 연결 관계, 연결 비용 등 단순 홉수가 아닌 가중치를 사용하여 최적의 결과를 계산한다
- 대역폭을 기반으로 메트릭을 계산하여 최적의 경로를 선정한다
- 대역폭이 높은 링크일수록 메트릭이 낮은 경로로 인식

 대표적인 EGP
1. BGP(Border Gateway Protocol)
- AS 내의 통신을 위한 IBGP(Internal Border Gateway Protocol)
- AS 간의 통신을 위한 EBGP(External Border Gateway Protocol)
- 피어링이라는 다른 AS와의 BGP 연결을 유지하기 위해서 BGP 라우터끼리 피어가 되도록 연결하는 과정을 거친다
- BGP는 RIP와 OSPF에 비해 최적의 경로를 결정하는 과정이 복잡하고, 일정하지 않다
- 경로 결정 과정에서 수신지 주소와 더불어 다양한 속성과 정책이 고려되기 때문이다

 BGP의 속성
1. AS-PATH
- 메세지가 수신지에 이르는 과정에서 통과하는 AS들의 목록
- 메세지가 AS를 거칠 때마다 AS-PATH에는 거쳐 간 AS가 추가
2. NEXT-HOP 속성
- 홉, 다음으로 거칠 라우터의 IP 주소
3. LOCAL-PREF
- LOCAL PREFence의 약자, 지역 선호도
- AS 외부 경로 선택에 있어 AS 내부에서 어떤 경로를 선호할지에 대한 척도
- 일반적으로 AS-PATH나 NEXT-HOP 속성보다 우선시된다
- LOCAL-PREF 값은 AS 관리 주체가 설정하는 정책의 영향을 받음

28강
 전송 계층 개요
- 네트워크 계층과 응용 계층 사이의 계층
- 신뢰할 수 있는 통신과 연결형 통신 기능을 제공하여 네트워크 계층의 IP 한계를 보완한다
- 포트 번호를 활용하여 응용 계층의 프로세스 식별

 IP 기반 통신의 특징
- IP 패킷의 전달 = 신뢰성이 없는 통신 + 비연결형 통신
1. 신뢰할 수 없는 프로토콜(Unreliable Protocol)
- 패킷이 수신지까지 제대로 전송되었다는 보장을 하지 않음
- 통신 과정에서 패킷이 잘못 전송되어도 이를 확인하지 않고, 재전송도 하지 않으며, 순서대로 패킷이
도착할 것이라는 보장도 하지 않음
2. 비연결형 프로토콜(Connectionless Protocol)
- 송수신 호스트 간에 사전 연결 수립 작업을 거치지 않음
- 그저 수신지를 향해 패킷을 일방적으로 보내기만 할 뿐이다

 IP가 신뢰할 수 없는, 비연결형 통신을 하는 이유
- 신뢰할 수 있는 통신은 더 많은 연산으로 인해 성능이 저하됨
- 모든 경우에 신뢰성 있는 전송을 필요한 것은 아니기에 후술할 전송 계층에 신뢰성 있고 연결형인 
통신을 따로 두었다

 전송 계층의 프로토콜
1. TCP
- 송수신하는 동안에는 연결을 유지하고, 송수신이 끝나면 연결을 종료한다
- 재전송을 통한 오류 제어, 흐름 제어, 혼잡 제어 등 다양한 기능들을 제공
2. UDP
- 신뢰할 수 없는 통신, 비연결형 통신을 가능하게 함
- TCP보다 비교적 빠른 전송이 가능

 응용 계층을 식별하는 전송 계층
- 패킷의 최종 도달점은 호스트가 아니라 호스트의 특정 프로세스이다
 
 포트의 정의
- 패킷 내 수신지 포트와 송신지 포트를 통해 송수신지 호스트의 프로세스를 식별한다
- 16비트로 표현 가능하며 사용한 포트의 수는 2의 16제곱으로 65536개다
- 정수 번호의 형태를 띄며 0 ~ 65535번까지 존재한다
 
 포트의 분류
1. 잘 알려진 포트(Well Known Port)
- 0번부터 1023번까지의 포트
- 시스템 포트(System Port)
- 범용적으로 사용되는 애플리케이션(프로세스) 프로토콜이 일반적으로 사용하는(예약한것처럼)포트 번호를 의미
- 인터넷 할당 번호 관리 기관(IANA; Internet Assigned Numbers Authority)에서 관리한다. 다만 권고일 뿐 강제는 아니다
2. 등록된 포트(Registered Port)
- 포트 번호 1024번부터 49151번까지
- 잘 알려진 포트에 비해서는 덜 범용적
- 흔히 사용되는 애플리케이션 프로토콜에 할당하기 위해 사용
- 인터넷 할당 번호 관리 기관(IANA; Internet Assigned Numbers Authority)에서 관리한다. 다만 권고일 뿐 강제는 아니다
3. 동적 포트(Dynamic Port), 사설 포트(Private Port), 임시 포트(Ephemeral Port)
- 특별히 관리되지 않는 포트 번호 범위로 자유롭게 사용 가능
- 서버는 대부분 잘 알려진 포트와 등록된 포트를 사용한다
- 클라이언트는 대부분 동적 포트를 사용한다

특정 호스트에서 실행 중인 특정 애플리케이션 프로세스를 식별하기 위해 IP 주소:포트 번호 형식을 사용한다

 NAT 추가
- NAT 테이블에 사설 IP와 공인 IP를 저장하여 변환한다
- 사설 IP와 공인 IP가 변환되는 과정에서 각 옥텟이 대응된다
- 이 과정에서 사설 IP 주소의 수만큼 공인 IP 주소가 필요하기에 낭비가 발생한다
 
 포트 기반의 NAT, NAPT
- NAPT(Network Address Port Translation) 또는 PAT(Port Address Translation)이라고 부른다
- NAPT는 NAT 테이블에 변환할 IP 주소 쌍과 더불어 포트 번호도 저장하여 사용한다
- 복수개의 사설 IP 주소가 하나의 공인 IP 주소를 사용하더라도 포트번호로 구분이 가능하다
- 하나의 공인 IP 주소를 여러 사설 IP 주소가 1 : N으로 공유가능하여 공인 IP 주소 수 부족 문제를 해결
- 오늘날의 NAT는 대부분 NAPT이다

29강
 포트 포워딩
- 네크워크 내 특정 호스트에게 IP 주소와 포트 번호를 미리 할당하고 이후 해당 IP 주소:포트 번호로
패킷을 전달하는 기능

30강
 IP의 전송 특성을 보완하는 ICMP(네트워크 계층)
- IP 패킷 전송 과정에 대한 다음과 같은 피드백 메시지 제공
1. 전송 과정에서 발생한 문제 상황에 대한 오류 보고
2. 네트워크에 대한 진단 정보(네트워크상의 정보 제공)

- ICMP 메시지는 ICMP 메시지 유형번호인 타입과 구체적인 메시지 내용 번호인 코드로 구성되어 있다
- ICMP는 IP의 보조일 뿐 신뢰성을 완전히 보장하지는 못한다
- IP의 한계를 극복하기 위해서는 전송 계층의 TCP를 사용해야 한다
- TCP는 신뢰성 보장, 연결형 통신 등으로 IP의 한계를 극복하기는 하나 IP 자체의 동작에 대한 피드백은
존재하지 않기에 여전히 필요로 한다. 따라서 ICMP가 문제를 감지 및 보고를 하고 TCP가 문제를 진단하는
역할을 한다

31강
 TCP와 UDP
1. TCP(Trasmission Control Protocol)
- 신뢰할 수 있는 통신을 위한 연결형 프로토콜
2. UDP(User Datagram Protocol)
- TCP보다 신뢰성은 떨어지지만 비교적 빠른 통신이 가능한 비연결형 프로토콜

 MSS(Maximum Segment Size)
- TCP로 전송할 수 있는 최대 페이로드 크기
- MTU는 헤더 크기까지 포함이었으나, MSS는 헤더 크기를 제외한다

 TCP 세그먼트 구조
1. 송수신지 포트
- 송수신하는 포트 번호
2. 순서 번호(Sequence Number)
- 송수신되는 세그먼트 데이터의 첫 바이트에 부여되는 번호
- 세그먼트의 올바른 송수신 순서를 보장하기 위한 번호
- IPv4의 단편화 오프셋과 동일하다
- 순서 번호 = 초기 순서 번호(ISN, Initial Sequence Number, 무작위 값이 주어진다) + 송신한 바이트 수
3. 확인 응답 번호(Acknowledgment Number)
- 상대 호스트가 보낸 세그먼트에 대한 응답
- 다음으로 수신하기를 기대하는 순서 번호(일반적으로 수신한 순서 번호 + 1)가 명시
- 확인 응답 번호 값을 보내기 위해서는 제어 비트에서 승인을 나타내는 비트인 ACK 플래그를 1로 설정
ex) 순서 번호 7번이 송신되어 상대 호스트가 제대로 수신하였을때 확인 응답 번호는 8번이 적혀있다
4. 제어 비트(Control Bits) 또는 플래그 비트(Flag Bits)
- 현재 세그먼트에 대한 부가 정보
- 기본적으로 8비트로 구성되어 있으며 중요한건 아래 3가지와 같다
 1. ACK 
 - 현재 세그먼트를 수신하였음을 알리는 비트 
 2. Syn
 - 연결을 수립하기 위한 비트
 3. Fin
 - 연결을 종료하기 위한 비트
5. 윈도우(Window)
- 수신 윈도우(받을수 있는 총량)의 크기가 명시

 TCP 연결 수립과 종료
1. 연결 수립 : 쓰리 웨이 핸드셰이크
- 쓰리 웨이 핸드셰이크(Three-Way Handshake) 세 개의 단계로 이루어진 TCP의 연결 수립 과정
 1. A가 B에게 A의 초기 순서 번호와 1로 설정된 SYN 비트가 포함된 세그먼트를 보냄으로써 연결 시작을 요청한다
 2. B가 A에게 B의 초기 순서 번호와 1로 설정된 SYN 비트, 1로 설정된 ACK 비트, B의 확인 응답 번호(A의 초기 순서 번호 + 1)가
 포함된 세그먼트를 보내어 확인했음을 알린다
 3. A가 B에게 A의 다음 순서 번호와 A의 확인 응답 번호(B의 초기 순서 번호 + 1), 1로 설정된 ACK 비트가 포함된
세그먼트를 보내어 확인을 알린다
- 연결 시작 호스트의 연결 수립 과정을 액티브 오픈(Active Open), 연결 수락 호스트의 연결 수립 과정을 패시브 오픈(Passive Open)
이라고 한다
2. 연결 종료 : 포 웨이 핸드셰이크
- 포 웨이 핸드셰이크(Four-Way Handshake) 네 개의 단계로 이루어진 TCP의 연결 종료 과정
 1. A가 B에게 1로 설정된 FIN 비트가 포함된 세그먼트를 보냄으로써 연결 종료를 요청한다
 2. B가 A에게 1로 설정된 ACK 비트와 B의 확인 응답 번호가 포함된 세그먼트를 보냄으로써 확인했음을 알린다
 3. B가 A에게 1로 설정된 FIN 비트가 포함된 세그먼트를 보냄으로써 연결 종료를 수락한다
 4. A가 B에게 1로 설정된 ACK 비트와 A의 확인 응답 번호가 포함된 세그먼트를 보냄으로써 연결이 종료된다
- 연결 시작 호스트의 연결 수립 과정을 액티브 클로즈(Active Close), 연결 수락 호스트의 연결 수립 과정을 패시브 클로즈(Passive Close)
라고 한다
 
 TCP 상태
- 상태를 유지하고 활용하는 프로토콜을 스테이트풀 프로토콜(Stateful Protocol)이라고 하며 TCP가 그중 대표적인 예시다
- 그 반대로 스테이트리스 프로토콜(Stateless Protocol) 역시 존재하며 UDP와 HTTP가 있다

1. 연결이 수립되지 않은 상태
 1-1. CLOSED
 - 아무런 연결이 없는 상태
 1-2. LISTEN
 - 클라이언트의 SYN 세그먼트를 기다리는 상태
 - SYN 세그먼트를 보내기 이전 소켓 생성 및 IP, 포트 바인딩 단계로 서버는 통신이 있음을 감지하고 
클라이언트의 SYN 세그먼트가 수신되기 이전에 미리 LISTEN 상태가 된다
 - LISTEN 호스트(서버)에게 SYN 세그먼트를 보내면 쓰레 웨이 핸드셰이크가 시작된다
2. 연결 수립 상태
 2-1. SYN-SENT
 - 연결 요청을 보낸 뒤 대기하는 상태(클라이언트)
 - 액티브 오픈 호스트가 SYN 세그먼트를 보낸 뒤 그에 대한 응답인 SYN + ACK 세그먼트를 기다리는 상태
 2-2. SYN-RECEIVED
 - 패시브 오픈 호스트가 SYN + ACK 세그먼트를 보낸 뒤 그에 대한 ACK 세그먼트를 기다리는 상태
 2-3. ESTABLISHED
 - 연결이 확립되었음을 나타내는 상태
3. 연결 종료 상태
 3-1. FIN-WAIT-1
 - 액티브 클로즈 호스트가 패시브 클로즈 호스트에게 FIN 세그먼트를 보냈을때
 3-2. CLOSE-WAIT
 - FIN 세그먼트를 받은 패시브 클로즈 호스트가 ACK 세그먼트를 보내고 FIN 세그먼트를 보내기 전까지의 상태
 3-3. FIN-WAIT-2
 - FIN-WAIT-1 상태에서 ACK 세그먼트를 받고 상대 호스트의 FIN 세그먼트를 기다리는 상태
 3-4. LAST-ACK
 - CLOSE-WAIT 상태에서 FIN 세그먼트를 전송한 뒤 이에 대한 ACK 세그먼트를 기다리는 상태
 3-5. TIME-WAIT
 - 액티브 클로즈 호스트가 FIN 세그먼트를 수신한 뒤, 이에 대한 ACK 세그먼트를 전송한 뒤 접어드는 상태
 - 패시브 클로즈 호스트는 마지막 ACK 세그먼트를 수신하면 CLOSE 상태로 전이
 - TIME-WAIT 상태의 액티브 클로즈 호스트는 마지막 ACK 세그먼트가 패시브 클로즈 호스트로 수신하는 시간을
 기다린 뒤 CLOSE 상태로 전이

 UDP 데이터그램의 구조
- UDP는 TCP와 달리 비연결형 통신을 수행하는 신뢰할 수 없는 프로토콜
- 연결 수립 및 해제, 재전송을 통한 오류 제어, 혼잡 제어, 흐름 제어 등을 수행하지 않음
- 상태를 유지하지 않는 스테이트리스 프로토콜(Stateless Protocol)
- UDP는 TCP에 비해 적은 오버헤드로 패킷을 빠르게 처리
- 주로 실시간 스트리밍 서비스, 인터넷 전화처럼 실시간성이 강조되는 상황에서 TCP보다 더 많이 쓰임

32강
 TCP의 오류, 흐름, 혼잡 제어

 TCP의 기능
- 재전송을 기반으로 다양한 오류 제어
- 흐름 제어를 통해 처리할 수 있을 만큼의 데이터 송수신
- 혼잡 제어를 통해 네트워크가 혼잡한 정도에 따라 전송량 조절

 오류 검출과 재전송
- TCP 세그먼트의 체크섬 필드는 데이터가 훼손되었는지만을 알려주기 때문에 패킷이 유실되었거나
잘못된 주소로 송신되었거나 등 여러가지를 알수 없다
- 송신 호스트가 송신한 세그먼트에 문제가 발생했음을 인지할 수 있다
- 오류를 감지하게 되면 해당 세그먼트를 재전송할 수 있다

 재전송 기반 오류 제어
1. 중복된 ACK 세그먼트를 수신했을 때
- 호스트 A가 호스트 B에게 N번 세그먼트를 송신하지만 세그먼트가 손실된다
- 호스트 B는 여전히 N를 수신한적이 없기에 다시 한번 호스트 A에게 N번 세그먼트를 요청한다
- 호스트 A는 호스트 B에게 N번 세그먼트를 중복으로 요청받았기에 오류를 감지한다
2. 타임아웃이 발생했을 때
- 호스트가 세그먼트를 전송할 때마다 재전송 타이머(Retransmission Timer) 시작
- 타임아웃이 발생할 때까지 상대 호스트의 ACK 세그먼트를 받지 못하면 재전송
- 재전송 타이머가 만료되기 전이라도 세 번의 동일한 ACK 세그먼트를 받았다면 곧바로 재전송하는
빠른 재전송(Fast Retransmit)을 대부분의 TCP에서 사용하고 있다

 재전송 기법 : ARQ(Automatic Repeat Request, 자동 재전송 요구)
- 수신 호스트의 답변(ACK)과 타임아웃을 토대로 문제를 진단하고, 문제가 생긴 메시지를 재전송함으로써 
 신뢰성을 확보하는 방식
- 전송 계층이외에도 ARQ를 사용하는 계층 혹은 프로토콜이 있으나 가장 대표적으로 전송 계층과 TCP가 있다

 ARQ의 대표적인 세 가지 방식
1. Stop and Wait ARQ
- 제대로 전달했음을 확인하기 전까지는 새로운 메시지를 보내지 않는 방식
- 송신하고 확인받고 송신하고 확인받고를 반복함
- 단순하며 높은 신뢰성을 보장한다
- 네트워크의 이용 효율이 낮아지고 성능이 저하된다
- 성능 저하를 막기 위해 각 세그먼트에 대한 ACK 세그먼트가 도착하기 전이라도 여러 세그먼트를 보내야한다
- 연속해서 메시지를 전송할 수 있는 파이프라이닝(Pipelining)을 이용해서 보완한다
2. Go Back N ARQ
- 파이프라이닝 기반 ARQ의 일종
- 여러 세그먼트 전송 중 오류가 발생하면 해당 세그먼트부터 전부 재전송
- 만약 N ~ N + 3번까지의 세그먼트 송수신중 N + 2번이 오류가 난다면 수신 호스트는 제대로 전송받은
N + 3번 세그먼트 역시 폐기시키고 새로 수신받는다
- 순서 번호 N번에 대한 ACK 세그먼트는 N번만의 확인 응답이 아닌 N번까지의 누적 확인 응답으로
CACK(Cumulative Acknowledgment)라고 부른다   
3. Selective Repeat ARQ
- 선택적으로 재전송. 각각의 패킷들에 대해 ACK 세그먼트를 보내는 방식
- Go Back N ARQ의 ACK 세그먼트가 누적 확인 응답이라면 Selective Repeat ARQ의 ACK 세그먼트는 
개별 확인 응답(Selective Acknowledgment)이다
- 오늘날 대부분의 호스트는 Selective Repeat ARQ를 지원하며 그렇지 않을 경우
Go Back N ARQ로 동작한다

 TPC의 흐름 제어
- 파이프라이닝 기반의 Go Back N ARQ/Selective Repeat ARQ가 정상 작동하려면 호스트가 한 번에
받아서 처리할 수 있는 세그먼트의 양을 고려해야 하며 이것을 흐름 제어라고 한다
- 송신 호스트가 수신 호스트의 처리 속도를 고려하며 송수신 속도를 균일하게 유지하는 기능
- Stop and Wait ARQ를 사용하면 별도의 흐름 제어가 필요하지 않음
- 파이프라이닝 기반의 Go Back N ARQ와 Selective Repeat ARQ에는 흐름 제어가 필요하다

 TCP 흐름 제어 기법
1. 슬라이딩 윈도우(Sliding Window)
- 윈도우란 송신 호스트가 파이프라이닝할 수 있는 최대량 즉, 윈도우의 크기만큼 확인 응답을 받지 않고도
한 번에 전송 가능하다는 의미
- DP의 슬라이딩 윈도우와 동일하며 1 ~ N번까지가 현재 윈도우의 범위일때 1번 세그먼트에 대해 ACK 세그먼트를
받았다면 범위는 2 ~ N + 1로 변경되며 이를 반복한다
- 송신 측의 윈도우(송신 윈도우)도 존재하며 수신 호스트는 TCP 헤더(윈도우 필드)를 통해 송신 호스트에게 자신이
받을 데이터의 양을 알려주고 이를 바탕으로 송신 측에서 송신 윈도우 값을 계산하게 된다

 TCP의 혼잡 제어
- 혼잡이란 많은 트래픽으로 인해 패킷의 처리 속도가 늦어지거나 유실될 우려가 있는 네트워크 상황을 말한다
- 송신 호스트가 혼잡한 정도에 맞춰 유동적으로 전송량을 조절하는 기능
- 흐름 제어의 주체가 수신 호스트라면 혼잡 제어의 주체는 송신 호스트
- 혼잡 윈도우란 혼잡 없이 전송할 수 있을 법한 데이터양으로 당연히 양이 클수록 좋다
- 수신 윈도우는 수신 호스트가 송신 호스트에게 알려주지만 혼잡 윈도우는 송신 호스트가 직접 계산해야 한다

 TCP의 혼잡 제어 알고리즘들
1. AIMD(Additive Increase/Multiplicative Decrease)
- 가장 기본적인 알고리즘으로써 합으로 증가, 곱으로 감소를 한다
- 혼잡이 감지되지 않는다면 혼잡 윈도우를 RTT(Round Trip Time, 메세지를 전송한 뒤 그에 대한 답변을
받는 데까지 걸리는 시간)마다 1씩 선형적으로 증가
- 혼잡이 감지되면 혼잡 윈도우를 절반으로 감소시키는 동작을 반복한다
- 송신 호스트가 네트워크 혼잡 상황을 판단하는 척도는 전송할 세그먼트에 오류가 있음을 감지하는 과정과 일치한다
(중복된 ACK 세그먼트를 수신했을 때, 타임아웃이 발생했을 때)
2. 느린 시작(Slow Start) 알고리즘
- 혼잡 윈도우를 1부터 시작해 문제 없이 수신된 ACK 세그먼트 하나당 1씩 증가시키는 방식
- 혼잡 윈도우는 RTT마다 2배씩 지수적으로 증가하며 초기 빠른 전송 속도를 확보할 수 있다
- 혼잡 윈도우는 느린 시작 임계치(Slow Start Threshold)라는 호스트마다 가지고 있는 고유한 값까지 증가하다가
다음과 같은 3가지 경우로 나뉘어지게 된다
 2-1. 혼잡 윈도우의 크기가 느린 시작 임계치 이상이 된다
 - 느린 시작 종료후 혼잡 회피 수행
 2-2. 타임아웃이 발생할 경우
 - 혼잡 윈도우를 1로 초기화후 느린 시작 재개
 2-3. 세 번의 중복된 ACK 세그먼트를 수신할 경우
 - 빠른 재전송 후 빠른 회복 진행

 혼잡 회피 알고리즘
- RTT마다 혼잡 윈도우를 지수적이 아닌 1씩 선형적으로 증가시켜 증가폭을 줄여서 혼잡을 회피하는 알고리즘
 빠른 회복(Fast Recovery) 알고리즘
- 세 번의 중복된 ACK 세그먼트를 수신한 상태이며 빠른 재전송 + 빠른 회복 알고리즘을 사용한다
- 타임 아웃보다 심각성이 적은 상황이므로 느린 시작은 건너뛰고 혼잡 회피를 수행하는 알고리즘
- 단, 빠른 회복 도중이라도 타임아웃이 발생하면 다시 느린 시작을 수행한다

33강
 명시적 혼잡 알림(ECN)
- 기존 혼잡 제어는 오로지 송신 호스트가 혼잡 윈도우를 계산해서 처리하지만 네트워크 장치(주로 라우터)의
도움을 받아 혼잡을 제어하는 방법
- 호스트가 ECN을 지원할 경우 TCP/IP 헤더에 ECN 관련 비트가 추가된다
- 송신 호스트만 혼잡 제어를 수행할 경우 문제가 발생한 이후에 비로소 혼잡 제어
- ECN을 이용하면 수신 호스트의 ACK 세그먼트를 통해(ECE 비트) 더 빠르게 혼잡을 감지
1. 송신 호스트에서 보낸 메시지가 라우터를 거쳐 수신 호스트로 도달할때 라우터가 혼잡을 감지하면
IP 패킷의 ECN 비트를 11로 바꾼다.
2. 수신 호스트가 송신 호스트에게 라우터가 혼잡을 감지했음을 TCP 세그먼트의 ECE 비트를 1로 바꾸어 알린다
3. 송신 호스트는 TCP 세그먼트의 CWR 비트를 1로 바꾸고 혼잡 윈도우를 조절한다

34강
 도메인 네임
- IP 주소만으로 송수신지 특정이 번거로움
- 통신하고자 하는 모든 호스트의 IP 주소를 기억하기 어려움
- IP 주소는 언제든지 바뀔 수도 있음(동적 IP)
- 상대 호스트 특정을 위해 도메인 네임 사용(공용 전화번호부)
- 호스트의 IP 주소와 대응되는 문자열 형태의 호스트 특정 정보(ex www.naver.com)
- 네임 서버(DNS 서버)에서 관리하며 IP 주소가 변경되어도 도메인 네임을 다시 대응하면 된다
- 호스트 자체에도 hosts 파일이라는 도메인 네임과 IP 주소의 대응 관계를 담은 파일을 개인 전화번호부처럼
저장하고 있다

 도메인 네임의 구조
- 점(.)을 기준으로 계층적으로 분류
- 점(.)으로 끝나지만(루트 도메인) 보통 생략되어 있다
- 최상위 도메인(TLD; Top-Level-Domain)
- N단계 도메인은 뒤에서부터 .으로 구분된다

 전체 주소 도메인 네임(FQDN; Fully-Qualified Domain Name)
- 전체 도메인 계층을 모두 포함하는 도메인 네임
- FQDN까지 알면 비로소 하나의 호스트를 식별할 수 있게 됨
- www(3단계).naver(2단계).com(최상위 도메인).(루트 도메인)

 서브 도메인
- 다른 도메인이 포함된 도메인
- google.com의 서브 도메인
1. mail.google.com
2. www.google.com
3. scholar.google.com
4. drive.google.com

 네임 서버의 관리
- 도메인 네임은 계층적으로 구성되어 있기에 이를 관리하기 위한 네임 서버 또한 계층적으로 관리
- 네임 서버는 부하를 줄이기 위해서 전 세계 여러 군데 분산되어 위치
- 계층적으로 분산된 도메인 네임에 대한 관리 체계(Domain Name System; DNS)

 도메인 네임에 대응하는 IP 주소를 알아내는 과정
- 도메인 네임을 풀이(Resolve)한다
- 계층적으로 분산된 네임 서버들이 사용됨
- 주요 네임 서버의 유형
1. 로컬 네임 서버
- 클라이언트가 도메인 네임을 통해 IP 주소를 알아내고자 할 때 가장 먼저 찾게 되는 네임 서버
- 로컬 네임 서버의 주소는 일반적으로 ISP에서 할당
- 공개 DNS 서버 Public DNS Server를 이용할 수도 있음(구글의 8.8.8.8, 8.8.4.4)
- 클라이언트로부터 받은 도메인 주소를 루트 네임 서버에게 물어본다
2. 루트 네임 서버
- 루트 도메인을 관장하는 네임 서버
- 로컬 네임 서버가 대응하는 IP 주소를 모를 경우 TLD 네임 서버의 IP 주소를 반환할 수 있음
- 수없이 많은 .으로 끝나는 도메인 주소가 존재하기 때문에 오직 TLD 도메인의 주소만을 알고 있다 
3. TLD(최상위 도메인) 네임 서버
- TLD를 관리하는 네임 서버
- DNS 질의에 대해 TLD의 하위 도메인 네임을 관리하는 네임 서버 주소 반환
- 하위 도메인 네임을 관리하는 네임 서버는 그보다 하위 도메인 네임을 관리하는 네임 서버 주소를 반환
- TLD로 끝나는 수많은 도메인 주소가 있기 때문에 오직 하위 네임 서버의 주소만을 알고 있다
4. 책임 네임 서버
- 특정 도메인 영역(zone)을 관리하는 네임 서버
- 다른 네임 서버에게 떠넘기지 않고 곧바로 답할 수 있는 네임 서버
- 책임 네임 서버는 로컬 네임 서버가 마지막으로 질의하는 네임 서버  
- 일반적으로 로컬 네임 서버는 책임 네임 서버로부터 원하는 IP 주소를 알아냄
- 해당 네임 서버에서 특정 도메인 주소의 IP 주소를 알고 있다면 바로 알려주고 그렇지 않다면
더욱 하위 네임 서버의 주소를 알려준다

 예를 들어 www.naver.com의 IP 주소를 알아낼때는 다음과 같다
1. 로컬 네임 주소에서 루트 네임 서버에 .에 관련한 IP 주소를 물어보지만 TLD 서버에 대한 주소를 알려준다
2. TLD 서버에 com.에 관한 IP 주소를 물어보나 2단계 서버에 대한 주소를 알려준다
3. naver.com.에 대한 IP 주소를 물어보고 www.naver.com에 대한 IP 주소를 안다면 알려주고 그렇지 않다면
더욱 하위 네임 서버에 대한 주소를 알려준다
4. www.naver.com.에 대한 주소를 알고 있는 3단계 서버에서 IP 주소를 알게 된다

 네임 서버의 계층적 질의
1. 재귀적 질의(Recursive Query)
- 클라이언트 -> 로컬 네임 서버 -> 루트 네임 서버 -> TLD 네임 서버 -> 책임 네임 서버 순서로 질의
- 책임 네임 서버가 IP 주소를 상위 네임 서버에게 반환하고 이 과정이 반복되어 클라이언트에게 돌아옴
2. 반복적 질의(Iterative Query)
- 루트 네임 서버, TLD 네임 서버, 책임 네임 서버에게 순서대로 질의-응답 반복
- 각 네임 서버가 하위 네임 서버와 질의-응답을 하는 재귀적 질의와는 다르게 로컬 네임 서버가
각 네임 서버들에게 순서대로 질문을 반복한다
//
- 앞선 예시는 8단계를 거치게 되는데 시간이 오래 걸리고 네트워크상의 메세지 수가 지나치게 늘어날 수 있다
- 첫번째 질의를 담당하는 루트 네임 서버에 과부하 우려

 DNS 캐시
- 네임 서버들이 기존에 응답받은 결과를 임시로 저장했다가 추후 같은 질의에 이를 활용
- DNS 캐시를 저장하는 용도로만 사용되는 서버도 있음
- DNS 캐시를 활용하면 더 짧은 시간 안에 원하는 IP 주소를 얻어낼 수 있음
- DNS 캐시는 영원하지 않으며 임시 저장된 값은 TTL(Time To Live)값과 함께 저장

 자원(Resource)
- 두 호스트가 네트워크를 통해 서로 정보를 주고받을 때, 송수신하는 대상
1. HTML 파일
2. 이미지나 동영상 파일
3. 텍스트 파일 등
- 또는 응용 계층의 HTTP 프로토콜이 요청하는 대상을 칭하기도 한다

 자원을 식별할 수 있는 정보, URI(Uniform Resource Identifier)
1. URL(Uniform Resource Locator)
- 위치를 이용해 자원을 식별
2. URN(Uniform Resource Name)
- 이름을 이용해 자원을 식별

 URL의 구조
1. scheme
- 자원의 접근하는 방법을 의미
- 일반적으로 사용할 프로토콜이 명시(HTTP, HTTPS)
2. authority
- 호스트를 특정할 수 있는 정보, 이를테면 IP 주소나 도메인 네임이 명시
- 콜론(:) 뒤에 포트 번호를 덧붙일 수도 있음
3. path
- 자원이 위치한 경로가 명시
- 자원의 위치는 슬래시(/)를 기준으로 계층적으로 표현되고, 최상위 경로 또한 슬래시로 표현
- http://example.com/home/images/a.png
4. query
- HTTP는 요청-응답 기반의 프로토콜
- 클라이언트는 서버에게 URI(URL)가 포함된 HTTP 요청 메세지를 보내고, HTTP 서버는 이에 대해 HTTP
응답 메세지를 보냄
- 검색 결과, 정렬 결과처럼 scheme, authority, path만으로는 표현할 수 없는 경우에 사용
- 쿼리 문자열(Query String), 쿼리 파라미터(Query Parameter)라고도 부름
- 물음표(?)로 시작되는 <키, 값> 형태의 데이터
- 앰퍼샌드(&)로 여러 쿼리 문자열을 덧붙일 수 있음
5. fragment
- 자원의 한 조각을 가리키기 위한 정보
- HTML 파일과 같은 자원에서 특정 부분을 가리키기 위해 사용

 URL과 URN의 단점
1. URL
- 위치를 기반으로 자원을 식별하는데 자원의 위치는 언제든 변할 수 있음
- 자원의 위치가 변경되면 기존의 URL로는 자원을 식별할 수 없음
2. URN
- 자원에 고유한 이름을 붙이는 이름 기반 식별자이기에 자원의 위치와 무관하게 자원을 식별
- 모든 자원에 이름을 붙이는 작업이 번거롭고, 호스트가 이름이 붙은 자원을 공유하기가 힘들기 때문에
URL에 비해 널리 채택되지 않는다

35강
 DNS 자원 레코드(DNS Resource Record)
- DNS 서버에서 저장하는 값
- 이름(도메인 이름)
- 값
- TTL(저장되는 시간)
- 레코드 유형(타입)

 레코드 유형
- 레코드 유형이 달라지면 레코드 이름과 값의 의미가 달라짐
1. A 
- 특정 호스트에 대한 도메인 네임과 IPv4 주소와의 대응관계
2. AAAA 
- 특정 호스트에 대한 도메인 네임과 IPv6 주소와의 대응관계
3. CNAME
- 호스트 네임에 대한 별칭 지정
- 기존에 존재하는 도메인 네임을 참조하듯 사용된다
4. NS
- 특정 호스트의 IP 주소를 찾을 수 있는 네임 서버
5. MX
- 해당 도메인과 연동되어 있는 메일 서버
    
36강
 HTTP
- 사용자와 밀접하게 맞닿아 있는 프로토콜
- 웹 세상의 기반이 되는 가장 중요한 프로토콜
1. 요청-응답 기반
- HTTP 요청 메시지와 HTTP 응답 메시지의 형태가 다르다
2. 미디어 독립적
- 주고받을 자원의 특성과 무관하게 자원을 주고받을 수단(인터페이스) 역할만 함
- HTML, JPEG, PNG, JSON, XML, PDF 등 다양한 종류의 자원 송수신 가능
- URI로 구분한다
3. 상태를 유지하지 않음(Stateless)
- 서버가 HTTP 요청을 보낸 클라이언트와 관련된 상태를 기억하지 않는다
- 클라이언트의 모든 HTTP 요청은 기본적으로 독립적인 요청으로 간주
- HTTP 서버는 일반적으로 많은 클라이언트와 동시에 상호 작용
- 모든 클라이언트의 상태 정보를 유지하는 것은 큰 부담
- HTTP가 상태를 유지하는 프로토콜이라면 성능의 향상을 위해 주로 자신의 상태를 기억하는 
특정 서버하고만 통신. 이때 그 서버에 문제가 생기면 클라이언트의 정보들은 날라간다
- 확장성(Scalability)과 견고성(Robustness)로 특정 클라이언트가 특정 서버에 종속되지 않게 하며, 
서버에 문제가 생겨도 다른 서버로 대체 용이
4. 지속 연결을 지원함
 4-1. 비지속 연결
 - HTTP 초기 버전
 - TCP 연결 이후 요청에 대한 응답을 받으면 연결 종료
 - 추가적인 요청-응답을 하기 위해서는 다시 TCP 연결(쓰리 핸드 셰이크) 수립부터 반복
 4-2. 지속 연결 또는 킵 얼라이브
 - 최근 대중적으로 사용되는 HTTP 버전
 - 하나의 TCP 연결상에서 여러 개의 요청-응답을 주고 받을 수 있는 기술
 - 반복되는 연결 수립이 없기에 훨씬 더 빠르다

 미디어 타입(Media Type) 
- HTTP에서 메시지로 주고받는 자원의 종류. 웹 세상의 확장자
- 슬래시를 기준으로 '타입/서브타입(Type/Subtype)' 형식으로 구성
- 타입은 데이터의 유형이며, 서브타입은 주어진 타입에 대한 세부유형이다
- 미디어 타입에는 부가적인 설명을 위해 선택적으로 매개변수 포함 가능
- 타입/서브타입;매개변수=값의 형식으로 표현(ex type/html;charset=UTF-8)
- 여러 미디어 타입을 통칭할 때에는 *을 사용한다(ex text/* = text 타입의 모든 서브타입, */* = 모든 미디어 타입)

 미디어 타입의 종류
1. Text
- 텍스트 형식
2. Image
- 이미지 형식
3. Video
- 비디오 형식
4. Audio
- 오디오 형식
5. Application
- 바이너리 형식의 데이터(PDF, XML, JSON 등)
6. Multipart
- 각기 다른 미디어 타입을 가질 수 있는 여러 요소로 구성된 데이터
- HTML 입력 폼 데이터, 암호화된 데이터 등

 HTTP 메시지 구조
- 시작 라인, 필드 라인, 메시지 본문으로 구성
- 필드 라인은 없거나 여러 개 있을 수도 있음
- 메시지 본문은 없을 수도 있음
- 필드 라인과 메시지 본문 사이에는 빈 줄바꿈이 있음
- ex) 시작 라인
      필드 라인

      메시지 본문
1. 시작 라인
- HTTP 메시지가 HTTP 요청 메시지일 경우 시작 라인은 요청 라인,
HTTP 메시지가 HTTP 응답 메시지일 경우 시작 라인은 상태 라인이 되며 이때 두 라인은 형태가 다르다
 1-1. 요청 라인
 - 메서드(공백)요청대상(공백)HTTP 버전(줄바꿈)의 구조를 가진다
  1-1-1. 메서드
  - 메서드는 클라이언트가 서버의 자원(요청 대상)에 대해 수행할 작업의 종류이며 대표적으로 GET, POST, PUT, 
  DELETE 등이 있다
  1-1-2. 요청 대상
  - HTTP 요청을 보낼 서버의 자원
  - 보통 (쿼리가 포함된) URI의 경로가 명시
  - 만약 하위 경로가 없더라도 요청 대상은 슬래시(/)로 표기
  1-1-3. HTTP 버전
  - 'HTTP/버전'이라는 표기 방식을 따르며, HTTP 버전 1.1은 HTTP/1.1로 표기
 1-2. 상태 라인
 - HTTP 버전(공백)상태 코드(공백)이유 구문(줄바꿈)의 구조를 가진다
 - 상태 코드는 요청에 대한 결과를 나타내는 세 자리 정수
 - 이유 구문은 상태 코드에 대한 문자열 형태의 설명
2. 필드 라인 또는 헤더 라인
- 0개 이상의 HTTP 헤더 명시
- HTTP 헤더는 HTTP 통신에 필요한 부가 정보를 뜻한다
- 콜론(:)을 기준으로 헤더 이름과 하나 이상의 헤더값으로 구성된다
3. 메시지 본문
- HTTP 요청 혹은 응답 메시지에서 본문이 필요할 경우 선택적으로 메시지 본문에 명시
- 다양한 컨텐츠 타입이 사용 가능

 HTTP 메서드 정리
1. GET
- 특정 자원을 조회할 때 사용되는 메서드(ex 웹 브라우저 URL 입력)
- 클라이언트가 서버에게 '이 자원을 가져다주세요'라고 요청을 보내는 것과 같다
- 메시지 본문보다 쿼리 문자열이 더 자주 사용된다
2. HEAD
- HEAD 메서드를 사용하면 서버는 요청에 대한 응답으로 응답 메시지의 헤더만을 반환
3. POST
- 서버로 하여금 특정 작업을 처리하도록 요청하는 메서드. ex) 웹 사이트의 [게시하기] 버튼 클릭시
- 처리할 방식, 대상등은 흔히 메시지 본문으로 되기에 자주 쓰인다
- 많은 경우 '클라이언트가 서버에 새로운 자원을 생성하고자 할 때' 사용
- 새로운 자원이 생성시 서버는 응답 메시지의 Location 헤더를 통해 새로 생성된 자원의 위치를 알려 줌
4. PUT
- 요청 자원이 없다면 메시지 본문으로 자원을 새롭게 생성
- 요청 자원이 존재한다면 메시지 본문으로 자원을 완전히 대체
5. PATCH
- PUT 메서드가 덮어쓰기/대체라면 PATCH는 부분적 수정이다
- 메시지 본문에 맞게 자원 일부 수정
6. DELETE
- 특정 자원을 삭제하고 싶을 때 사용

 개발자 입장에서 생각해보는 HTTP 메서드
- 어떤 URL에 어떤 메서드로 요청 받았을 때 서버가 어떻게 행동하는 지는 오로지 개발자의 몫이다
- 어떤 메서드는 구현하고, 어떤 메서드는 구현하지 않을 수도 있다
- 같은 URL에 대해 메서드별 동작을 여러 개 구현할 수도 있음(같은 URL이지만 메서드가 다를때)

 HTTP 상태 코드
- 상태 코드의 종류는 백의 자리 수를 기준으로 유형을 구분한다
1. 100번대
- 정보성 상태 코드
2. 200번대
- 성공 상태 코드
- 주요 상태 코드 
 2-1. 200
 - 요청이 성공했음(OK)
 2-2. 201
 - 요청이 성공했으며, 새로운 자원이 생성되었음(Created)
 - POST 요청으로 서버에 새로운 자원이 생성시 응답 메시지의 Location 헤더를 통해 새로 생성된 자원의 위치를 알려 줌
 2-3. 202
 - 요청을 잘 받았으나, 아직 요청한 작업을 끝내지 않았음(Accepted)
 - 요청 결과를 곧바로 응답하기 어려운 경우
 - 작업 시간이 긴 대용량 파일 업로드 작업
 2-4. 204
 - 요청이 성공했지만, 메시지 본문으로 표시할 데이터가 없음(No Content)
3. 300번대
- 리다이렉션 상태 코드
- 요청을 완수하기 위해 추가적인 조치가 필요한 상태를 리다이렉션이라고 한다
- 클라이언트가 요청한 자원이 다른 곳으로 옮겨졌을 때, 클라이언트의 요청을 다른 곳으로 이동시키는 것
- 200번인줄 알고 클라이언트가 요청 메시지를 보냈으나 300번으로 옮겨진 상태이기에 서버쪽에서 300번쪽으로
메시지를 다시 보내라고 하는 경우
 3-1. 영구적인 리다이렉션
 - 자원이 완전히 새로운 곳으로 이동하여 경로가 영구적으로 재지정
 - 기존의 URL에 요청 메시지를 보내면 항상 새로운 URL로 리다이렉트
 - 기존 URL와 관련된 정보들이 더이상 필요없으므로 폐기한다
 3-1-1 301
 - 영구적 리다이렉션. 재요청 메서드 변경될 수 있음(Moved Permanently)
 - 내용을 변경하는 POST 메서드 진행중 자원의 위치가 변경되어 301을 반환할때 보안상의 이유로
 POST가 아닌 다시 GET 메서드부터 시작하여 자원을 얻는다
 3-1-2 308
 - 영구적 리다이렉션. 재요청 메서드 변경되지 않음(Permanent Redirect)
 3-2. 일시적인 리다이렉션
 - 자원의 위치가 일시적으로 변경되었거나 임시로 사용할 URL이 필요한 경우에 주로 사용
 - 기존 URL에 관련된 정보들을 폐기해서는 안되며 여전히 가지고 있다
 3-2-1 302
 - 일시적 리다이렉션. 재요청 메서드 변경될 수 있음(Found)
 3-2-2 303
 - 일시적 리다이렉션. 재요청 메서드 GET으로 변경(See Other)
 3-2-3 307
 - 일시적 리다이렉션. 재요청 메서드 변경되지 않음(Temporary Redirect)
4. 400번대
- 클라이언트 에러 상태 코드
 4-1. 400
 - 클라이언트의 요청이 잘못되었음(Bad Request)
 4-2. 401
 - 요청한 자원에 대한 유효한 인증이 없음(Unauthorized)
 - 권한을 떠나 인증 자체가 되지 않은 경우
 4-3. 403
 - 요청이 서버에 의해 거부됨(ex 접근 권한이 없을 경우)(Forbidden)
 - 인증은 되었으나 권한이 없는 경우
 4-4. 404
 - 요청받은 자원을 찾을 수 없음(Not Found)
 - 존재하지만 공개되지 않은 자원의 경우에도 쓰인다
 4-5. 405
 - 요청한 메서드를 지원하지 않음(Method Not Allowed)
 - 예를 들어 PATCH 메서드를 구현하지 않았는데 PATCH 메서드 요청을 할 때
5. 500번대
- 서버 에러 상태 코드
- 클라이언트가 올바르게 요청을 보냈을지라도 발생할 수 있는 서버 에러에 대한 상태 코드
 5-1. 500
 - 요청을 처리할 수 없음(Internal Server Error)
 - 보안상의 이유로 서버 내 에러를 통칭한다
 5-2. 502
 - 클라이언트와 서버 중간 서버의 통신 오류(Bad Gateway)
 5-3. 503
 - 현재는 요청을 처리할 수 없으나 추후 가능할 수도 있음(Service Unavailable)
 - 서버가 과부하 상태에 있거나 일시적인 점검 상태일 때 볼 수 있는 상태
 - 언제쯤 처리 가능한지 시간등을 통해 알려줌

37강
 HTTP의 버전
1. HTTP/0.9
- 현재 거의 사용되지 않는 초창기 HTTP 버전
- 사용 가능한 메서드는 GET뿐이며 헤더를 지원하지 않는다
2. HTTP/1.0
- HEAD, POST 등 GET 이외의 메서드 도입
- 헤더를 지원 시작
- 공식적으로는 지속 연결 미지원
3. HTTP/1.1
- 오늘날까지 널리 사용되는 버전
- 지속 연결 공식적 지원
- 파이프라이닝, 콘텐츠 협상 등 다양한 편의 기능 추가
- 메세지 본문 = 평문(TEXT)
- 1.1버전까지의 고질적 문제가 바로 HOL(Head of ling Blocking)이다
- 같은 큐에 대기하며 순차적으로 처리되는 여러 패킷이 있을 경우 첫 번째 패킷의 처리 지연으로
인해 나머지 패킷 처리도 모두 지연되는 문제 상황
4. HTTP/2.0
- 1.1과 마찬가지로 오늘날까지 널리 사용되고 있다
- HTTP/1.1의 효율과 성능을 높이기 위한 버전
- 메시지 본문 = 바이너리 데이터
- 헤더 압축 전송 가능
- 서버 푸시(Server Push) 기능
- 클라이언트가 요청하지 않았더라도 미래에 필요할 것으로 예상되는 자원 미리 전송하는 기능
(A와 B가 세트로 사용될때 현재 요청은 A만 왔지만 B도 쓰일것이므로 B도 미리 전송함)
- HTTP 멀티플렉싱(Multiplexing)을 통한 HOL 블로킹 완화
- 여러 스트림(Stream)을 활용해 병렬적으로 메시지를 주고받는 기술
- 요청-응답 단위는 하나의 스트림에서 이루어짐
- 스트림별 독립적인 송수신 가능
- 별도의 스트림을 통해 여러 데이터를 병렬적으로 주고받으며 HOL 블로킹 완화
5. HTTP/3.0
- 이전까지의 HTTP는 TCP였으나 3.0은 UDP 기반 프로토콜인 QUIC(Quick UDP Internet Connections)
기반으로 동작
- 연결형 프로토콜 기반 송수신 속도 < 비연결형 프로토콜 기반 송수신 속도
- 헤더 혹은 비연결형 등의 특성으로 인해 TCP 기반보다 훨씬 빠르다

38강
 HTTP 헤더
- 필드 이름(헤더 이름)과 필드 값(헤더 값)이 콜론(:)을 기준으로 구분
1. 특별한 사전 지식이 필요하지 않은 헤더
- HTTP 요청 시 주로 사용되는 헤더
 1. HOST
 - 요청을 보낼 호스트를 나타내는 헤더
 - 주로 도메인 네임 명시, 포트 번호가 포함되어 있을 수 있음
 2. User-Agent
 - HTTP 요청을 시작하는 클라이언트 측의 프로그램(ex 웹 브라우저)
 - 요청 메시지 생성에 관여한 클라이언트 프로그램과 관련된 다양한 정보가 명시
- HTTP 응답 시 주로 사용되는 헤더
- HTTP 요청과 응답 모두에서 자주 활용되는 헤더
2. 사전 지식이 필요한 캐시, 쿠키, 콘텐츠 협상 관련 헤더로
나눌수 있다